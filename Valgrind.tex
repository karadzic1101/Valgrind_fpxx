% Format teze zasnovan je na paketu memoir
% http://tug.ctan.org/macros/latex/contrib/memoir/memman.pdf ili
% http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf
% 
% Prilikom zadavanja klase memoir, navedenim opcijama se podešava 
% veličina slova (12pt) i jednostrano štampanje (oneside).
% Ove parametre možete menjati samo ako pravite nezvanične verzije
% mastera za privatnu upotrebu (na primer, u b5 varijanti ima smisla 
% smanjiti 
\documentclass[12pt,oneside]{memoir}

% Paket koji definiše sve specifičnosti mastera Matematičkog fakulteta
\usepackage{matfmaster}
%
% Podrazumevano pismo je ćirilica.
%   Ako koristite pdflatex, a ne xetex, sav latinički tekst na srpskom jeziku
%   treba biti okružen sa \lat{...} ili \begin{latinica}...\end{latinica}.
%
% Opicija [latinica]:
%   ako želite da pišete latiniciom, dodajte opciju "latinica" tj.
%   prethodni paket uključite pomoću: \usepackage[latinica]{matfmaster}.
%   Ako koristite pdflatex, a ne xetex, sav ćirilički tekst treba biti
%   okružen sa \cir{...} ili \begin{cirilica}...\end{cirilica}.
%
% Opcija [biblatex]:
%   ako želite da koristite reference na više jezika i umesto paketa
%   bibtex da koristite BibLaTeX/Biber, dodajte opciju "biblatex" tj.
%   prethodni paket uključite pomoću: \usepackage[biblatex]{matfmaster}
%
% Opcija [b5paper]:
%   ako želite da napravite verziju teze u manjem (b5) formatu, navedite
%   opciju "b5paper", tj. prethodni paket uključite pomoću: 
%   \usepackage[b5paper]{matfmaster}. Tada ima smisla razmisliti o promeni
%   veličine slova (izmenom opcije 12pt na 11pt u \documentclass{memoir}).
%
% Naravno, opcije je moguće kombinovati.
% Npr. \usepackage[b5paper,biblatex]{matfmaster}

% Pomoćni paket koji generiše nasumičan tekst u kojem se javljaju sva slova
% azbuke (nema potrebe koristiti ovo u pravim disertacijama)
\usepackage{pangrami}

% Datoteka sa literaturom u BibTex tj. BibLaTeX/Biber formatu
\bib{matfmaster-primer}

% Ime kandidata na srpskom jeziku (u odabranom pismu)
\autor{Aлександра Караџић}
% Naslov teze na srpskom jeziku (u odabranom pismu)
\naslov{Алат \textit{Valgrind} - имплементација конвенције \textit{FPXX} за архитектуру \textit{MIPS} }
% Godina u kojoj je teza predana komisiji
\godina{2017}
% Ime i afilijacija mentora (u odabranom pismu)
\mentor{др Милена \textsc{Вујошецић Јаничић}, доцент\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija prvog člana komisije (u odabranom pismu)
\komisijaA{др Филип \textsc{Марић}, ванредни професор\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija drugog člana komisije (u odabranom pismu)
\komisijaB{др Јелена \textsc{Граовац}, доцент\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija trećeg člana komisije (opciono)
% \komisijaC{}
% Ime i afilijacija četvrtog člana komisije (opciono)
% \komisijaD{}
% Datum odbrane (obrisati ili iskomentarisati narednu liniju ako datum odbrane nije poznat)
\datumodbrane{15. јануар 2016.}

% Apstrakt na srpskom jeziku (u odabranom pismu)
\apstr{%
%\pangrami
}

% Ključne reči na srpskom jeziku (u odabranom pismu)
\kljucnereci{анализа, геометрија, алгебра, логика, рачунарство, астрономија}

\begin{document}
% ==============================================================================
% Uvodni deo teze
\frontmatter
% ==============================================================================
% Naslovna strana
\naslovna
% Strana sa podacima o mentoru i članovima komisije
\komisija
% Strana sa posvetom (u odabranom pismu)
\posveta{Деди}
% Strana sa podacima o disertaciji na srpskom jeziku
\apstrakt
% Sadržaj teze
\tableofcontents*

% ==============================================================================
% Glavni deo teze
\mainmatter
% ==============================================================================

% ------------------------------------------------------------------------------
\chapter{Увод}
% ------------------------------------------------------------------------------
%\pangrami

%\section{Примери коришћења класичних \LaTeX{} елемената}

% primer korišćenja tabele
%\begin{table}
%\centering
%\caption{Резултати}
%\label{tbl:rezultati}
%\begin{tabular}{c>{\centering}p{2cm}c}
%\toprule
%1 & 2 & 3\\\midrule
%4 & 5 & 6\\\cmidrule(rl){1-2}
%7 & 8 & 8\\
%\bottomrule
%\end{tabular}
%\end{table}

% primer korišćenja slike
%\begin{figure}[!ht]
%  \centering
%  \includegraphics[width=0.5\textwidth]{graph.png}
%  \caption{Графикон}
%  \label{fig:grafikon}
%\end{figure}

% primer jednostavnije matematičke formule
%Ево и један пример математичке формуле: $e^{i\pi} + 1 = 0$. 
% primer referisanja na sliku
%На слици \ref{fig:grafikon} приказан је један графикон.

% primer kompleksnije matematičke formule
%$$
%\int_a^b f(x)\ \mathrm{d}x \ =_{def}\ \lim_{\max{\Delta x_k \rightarrow 0}} \sum_{k=1}^n f(x_k^*)\Delta x_k
%$$

% primer referisanja na poglavlja i strane poglavlja
%Више детаља биће дато у глави \ref{chp:razrada} на страни \pageref{chp:razrada}.

% primer liste
%Можемо правити и набрајања:
%\begin{enumerate}
%\item Анализа 1
%\item Линеарна алгебра
%\item Аналитичка геометрија
%\item Основи програмирања
%\end{enumerate}

%\pangrami

% ------------------------------------------------------------------------------
\chapter{Архитектура \textit{MIPS}}
\label{chp:mips}
% ------------------------------------------------------------------------------
\subsection{MIPS}
MIPS је најелегантнија архитектура међу свим активним RISC архитектура, чак и по мишљењу конкуренције. Елеганција није довољна да би се освојило тржиште, али MIPS микропорцесори су успели бити међу најефикаснији сваком генерацијом остајући међу најједноставнијима.
MIPS процесори је један од RISC процесора, рођеног у плодном периоду академских истраживања и развоја. RISC  (енг. \textit{Reduced Instruction Set Computing}) је атрактивни акроним, 
~\cite{SeeMIPSRun}

\section{Регистри у MIPS-у}

\indent Регистри представљају малу, веома брзу меморију, која је део процесора. MIPS процесори могу вршити операције само над садржајима регистара и специјалним константама које су део инструкције. \\
\indent У MIPS архитектури, постоји 32 регистара опште намене. Само два регистара се понашају другачије од осталих регистара:
\begin{itemize}
  \item \textbf{\$0} - Увек враћа нулу, без обзира коју му се вредност додели
  \item \textbf{\$31} - Увек се користи за адресу повратка из функције на коју се скочи инструкцијом \textit{jal}
\end{itemize}
Сви ови регистри су идентични и могу се користити за било коју истрикцију (може се чак користити и регистар \$0 као дестинација, мада ће резултат да нестане). 

Регистри опште намене су описани у наставку:
\begin{itemize}
  \item \textbf{at} - Резервисан за псеудоинструкције које асемблер генерише
  \item \textbf{v0, v1} - Користи се за враћање резултата при повратку из неке функције. Резултат може бити целобројног типа или број записан у фиксном зарезу.
  \item \textbf{а0 - а3} - Користи се за прослеђивање прва 4 аргумената функције која се позива
  \item \textbf{t0 - t9} - по конвенцији која је описана 
  \item \textbf{s0 - s7} - по конвенцији која је описана 
  \item \textbf{k0, k1} - Резервисано за систем прекида, који након коришћења не враћа садржај ових регистара на почетни. Како се прекид не позива из програма који се тренутно извршава, нема примене позивне конвенције. То значи да се садржај регистара које прекинути програм користи може пореметити. Због тога, систем прекида прво сачува саджаје регистара опште намене, који су важни за програм који се у том тренутку извршавао, и чији садржај планира да мења. У те сврхе се користе ови регистри.
  \item \textbf{gp} - Користи се у различите сврхе. У коду који  не зависи од позиције (енг. \textit{Position Independent Code} скраћено PIC), свом коду и подацима се пристпуа преко табеле показивача, познате као GOT (скраћено од енг. \textit{Global Offset Table}). Регистар \textit{\$gp} показује на ту табелу. PIC је код који се може извршавати на било којој меморијској адреси, без модификација. PIC се најчешће користи за дељење библиотеке, при чему се заједнички код библиотеке може учитати у одговарајуће локације адресних простора различитих програма који је користе. \\
  У регуларном коду који зависи од позиције, регистар \textbf{\$gp} се користи као показивач на средину у статичкој меморији. То значи да се подацима који се налазе 32 КВ лево или десно од адресе која се налази у овом регистру може приступити помоћу једне инструкције. Дакле, инструкције \textit{load} и \textit{store} које се користе за учитавање, односно складиштење података, се могу извршити у само једној инструкцији, а не у две као што је иначе случај. У пракси се на ове локације смештају глобали подаци који не заузимају много меморије. Оно што је битно је да овај регистар не користи сви системи за компилацију и сва окружења за извршавање.
  
  \item \textbf{sp} - Показивач на стек. Оно што је битно је да стек расте наниже. Потребне су специјалне инструкције да би се показивач на стек повећао и смањио, тако да \textit{MIPS} ажурира стек само при позиву и повратку из фукције, при чему је за то одговорна функција која је позвана. \textit{sp} се при уласку у функцију прилагођава на најнижу тачку на стеку којој ће да приступати у функцији. Тако ј еомогућено да компилатор може да приступи поменљивама на стеку помоћу константног помераја у односу на \textit{\$sp}.
  \item \textbf{fp} - Познат и као \textit{\$s8}, показивач на стек оквир. Користи се од стране функције, за праћење стања на стеку, за случај да из неког разлога компилатор или програмер не могу да израчунају померај у односу на \textit{\$sp}. То се може догодити уколико програм врши проширење стека, при чему се вредност проширења рачуна у току извршавања. Ако се дно стека не може израчунати у току превођења, не може се приступити променљивама помоћу \textit{\$sp}, па се на почетку функције \textit{\$fp} иницијализује на константну позицију која одговара стек оквиру функције. Ово је локално за функцију.
  \item \textbf{ra} - Ово је подразумевани регистар за смештање адресе воратка и то је подржано кроз одговарајуће инструкције скока. Ово се разлицкује од конвеција које се корсите на архитеткурама џ86, где инструкција позива функције адресз повратка смешта на стек. При уласку у фукцију регистар \textit{ra} обично садржи адресу повратка фукције, тако да се функције углавном завршавају инструкцијом \textit{jr \$ra}, али у принципу, може се користити и неки други регистар. Због неких оптимизација које врши процесор, препоручује се коришћење регистара \textit{\$ra}. Функције које позивају друге функције морају сачувати садржај регистара \textit{\$ra}.
\end{itemize}

\indent Постоје два специјална регистра \textit{Hi} и \textit{Lo}, који се користе само при множењу и дељењу. ово нису регистри опште намене, те се не користе при другим инструцијама. Не може им се приступити директно, већ постоје специјалне инструкције \textit{mfhi} и \textit{mflo} за премештање садршаја ових регистара. Инструкција \textit{mfhi} је облика \textit{mfhi rd}, и она премешта садржај регистар \textit{Hi} у регистар \textit{rd}, док инструкција \textit{mflo} премешта садржај регистара \textit{Lo}.


\section{Floating point регистри у MIPS-у}

MIPS архитектура користи два формата FP (скр. \textit{Floating Point}) препоручена од стране IEEE 754:

\begin{itemize}
	\item \textit{Једнострука прецизност} (eнг. \textit{Single precision}) - Користи се 32 бита за чување у меморији. MIPS компајлери користе једноструку прецизност за променљиве типа \textit{float}
	\item \textit{Двострука прецизност} (eнг. \textit{Double precision}) - Користи се 64 бита за чување у меморији. C компајлери коисте двоструку прецизност за C \textit{double} типове података.
\end{itemize}

\indent Начин да се две речи ширине 32 бита се смештају у меморију као једна реч ширине од 64 бита је начин смештања у меморији (виша половина битова прво, или нижа половина битова прво) и зависи од начина смештања у меморији. 

\indent Стандартд IEEE 754 је веома захтеван и поставио је два велика проблема. Први, омогућавање детекције неуобичајних резултата доводи проточну обраду (енг. \textit{pipeline}) тешком. Постоји опција да се имплементира IEEE механизам сигнализирања изузетака, али је проблем да се детектују случајеви када хардвер не може да произведе исправан резултат и потребна му је помоћ.

\indent Када се IEEE изузетак деси требало би обевестити и корисника, ово би требало бити синхроно; након заустављања корисник би желио да види све предходно извршене инструкције и све FP регистре који су у preinstruction стању и желе да се увере да ни једна следећа инструкција нема никакав ефекат.

\indent У \textit{MIPS} архитектури, хардверска заустављања су била овако одрађена. Ово заправо ограничава могућности проточне обраде FP операција, јер се не може извршити сљедећа инструкције све док хардвер може бити сигуран да операција FP неће произвести заустављање. Зарад избегавања додавања времена за извршавање, FP операције морају да одлуче да ли ће доћи до заустављања у првој фази. 




\section{FPXX конвеција}

% ------------------------------------------------------------------------------
\chapter{Valgrind}
\label{chp:valgrind}

\indent \textit{Valgrind} је платформа за прављење алата за динамичку бинарну анализу кода. Динамичка анализа обухвата анализу корисничког програма у извршавању, док бинаран анализа обухвата анализу на нивоу машинског кода, снимљеног или као објектни код (неповезан) или као извршни код (повезан). Постоје \textit{Valgrind} алати који могу аутоматски да детектују проблеме са меморијом, процесима као и да изврше оптимизацију самог кода. \textit{Valgrind} се може користити и као алат за прављење нових алата. \textit{Valgrind} дистрибуција тренутно броји следеће алате: детектор меморијских грешака, детектор грешака нити, оптимизатор скривене меморије и скокова, генератор графа скривене меморије и предикције скока и оптимизатор коришћења динамичке меморије. \textit{Valgrind} ради на следећим архитектурама: 
\begin{flushleft}
\textbf{\textit{X86/Linux, AMD64/Linux, ARM/Linux, ARM64/Linux, PPC32/Linux, PPC64/Linux, PPC64LE/Linux, S390X/Linux, MIPS32/Linux, MIPS64/Linux, X86/Solaris, AMD64/Solaris, ARM/Android (2.3.x и новије), ARM64/Android, X86/Android (4.0 и новије), MIPS32/Android, X86/Darwin and AMD64/Darwin (Mac OS X 10.12)}}.
\end{flushleft}

\indent У наредним поглављима биће детаљно описана структура \textit{Valgrind} и његових алата, као и начин употребе са примерима проблема са којима се програмери свакодневно сусрећу.

\section{O Valgrindu}

\indent Алат за динамичку анализу кода се креира као додатак, писан у C програмског језику, на језгро \textit{Valgrind}. 


\begin{center}
\textit{Језгро Valgrinda + алат који се додаје = Алат Valgrinda} 
\end{center}


\indent Језгро \textit{Valgrind}-а омогућава извршавање клијетског програма, као и снимање извештаја који су настали приликом анализе самог програма. 

\indent Алати \textit{Valgrind}-а користе методу бојења вредности. Они заправо сваки регистар и меморијску вредност "боје" (замењују) са вредношћу која говори нешто додатно о оригиналној вредности. 

\indent Сви \textit{Valgrind} алати раде на истој основи, иако информације које се емитују варирају. Информације које се емитују могу се искористити за отклањање грешака, оптимизацију кода или било коју другу сврху за коју је алат дизајниран.

\indent Сваки \textit{Valgrind}-ов алат је статички повезана извршна датотека која садржи код алата и код језгра. Извршна датаоке valgrind представља програм омотач који је на основу --tool опције бира алат који треба покренути и покреће га помоћу системског позива \textbf{\textit{execve}}. Извршна датотека алата статички је линкована тако да се учитава почев од неке адресе која је обично доста изнад адресног простора који користе класичан кориснички програм (на \textbf{\textit{x86/Linux}} и \textbf{\textit{MIPS/Linux}} користи се адреса 0x38000000). У ретким случајевима, када та адреса није потреба, \textit{Valgrind} се може прекомпајлирати да користи неку другу адресу. \textit{Valgrind}-ово језгро прво иницијализује под-систем као што су менаџер адресног простора, и његов унутрашњи алокатр меморије и затим учитава клијентову извршну датотеку. Потом се иницијализују \textit{Valgrind}-ови субсистеми као што су транслациона табела, апарат за обраду сигнала, распоређивач нити и учитавају се информације за дебаговање клијента, уколико постоје. Од тог тренутка \textit{Valgrind} има потпуну контролу и почиње са превођењем и извршавањем клијентског програма. Може се рећи да \textit{Valgrind} врши JIT (\textit{Just In Time}) превођење машинског кода програма у машинкси код програма допуњен инструментацијом. Ниједан део кода клијента се не извршава у свом изворном облику. Алат се умеће у оригинални код на почетку, затим се нови код преводи, сваки основни блок појединачно, који се касније извршава. Процес превођења се састоји из рашчлањивања оригиналног машинског кода у IR (скр. \textit{intermediate representation}) који се касније инструментализује са алтом и поново преводи у нови машински код. 

\indent Резултат свега овога се назива транслација, која се чува у меморији и која се извршава по потреби. Језгро троши највише времан на сам процес прављења, проналажења и извршавања транслације. Оригинални код се никада се извршава. Једини проблем који се овде може догодити је ако се врши транслација кода који се мења током извршавања програма.

\indent IR има неке \textit{RISC} одлике као што су \textit{load/store}, свака операција ради само једну ствар, кад се линеаризује све операције раде само на привременим промељивама и литералима. Да би се подржале све целобројне, FP и SIMD операције над различитим величинама потребно је више од 200 примитвних аритметичко-логичких инструкција. 

\indent Постоје многе компликације које настају приликом смештања два програма у један процс (клијентски програм и програм алата). Многи ресурси се деле између ова два програма, као што су регистри или меморија. Такође, алат \textit{Valgrind}-а не сме да се одрекне тоталне контроле над извршавањем клијетског програма приликом извршавања системских позива, сигнала и нити.

\subsection{Основни блок}

\indent \textit{Valgrind} дели оригинални код у секвенце које се називају основни блокови. Основни блок је праволинијска секвенца машинског кода, на чији се почетак скаче, а која се завршава са скоком, позивом функције или повратком. Сваки код програма који се анализира поново се преводи на захтев, појединачно по основним блоковима, непосредно пре самог извршавања самог блока. Ако узмемо да су основни блокови клијетског кода \textit{BB1, BB2, ...} онда преведене основне блокове обележавамо са \textit{t(BB1), t(BB2), ...} Величина основног блока је ограничена на максимално 60 машинских инструкција. На процесорима \textit{MIPS}, инструкције скока и гранања имају такозвано "одложено извршавање". То значи да се приликом извршавања тих инструкција извршава и инструкција која се налази непосредно иза инструкције гранања или скока. У случају да је последња шесдесета инструкција основног блока инструкција гранања, \textit{Valgrind} учитава и инструкцију која се налази непосредно иза ње, односно шесдесет и прва инструкција. Тиме се омогућава конзистентно извршавање програма који се анализира, као и у случају да се програм извршава без посредства \textit{Valgrind}-а. Уколико након извршених 60 инструкција \textit{Valgrind} није наишао на инструкцију гранања, секвенца инструкција се дели на два или више основних блокова, који се извршавају један за другим.



\subsection{Системски позиви}

\indent Апликациони програми комуницирају са оперативним системом помоћу системских позива (eнг. \textbf{system calls}), тј. преко операција (функција) које дефинише оперативни систем.
\indent Системски позиви се реализују помоћу система прекида: кориснички програм поставља параметре системског позива на одређене меморијске локације или регистре процесора, иницира прекид, оперативни систем преузима контролу, узима парамтре, извршава тражене радње, резултат ставља на одређене меморијске локациј еили у регистре и враћа контролу корисчком програму. 
\indent Апликација која жели да користи неке од ресурса, као што су меморија, процесор или улазно/излазни уређаји, комуницира са језгром опративног система користећи системске позиве. Језгро оператвиног система дели виртуелну маморију на корисничку меморију и системску меморију. Системска меморија је одређена за само језгро оператвиног система, његова проширања, као и за урављачке програме. Кориснички прогстор је део меморије где се налазе све корсничке апликације приликом њиховог изврђавања. Корисничке апликације могу да приступе улазно/излазним уређајима, виртуелној меморији, датотекама ид ругим реуссрисам језгра оператвино система користећи само системске позиве. Системски позиви обезбеђују спрегу између програма који се извршава и оператвиног система. Генерално, реализују се на асемблерском језику, али новији виши програсмки језици, попут језика C и C++, такође омогућавају реализацију системског позива. Пграом кои се извршава може проседити параметре опративном систему на три начина:
\begin{itemize}
  \item прослеђивање параметара у регистрима процесора;
  \item постављањем параметара у меморијској табели, при чему се адреса табеле прослеђује у регистру процесора;
  \item постављањем параметара на врх стека (енг. \textit{push}), које оператвни систем "скида" (енг. \textit{pop}).
\end{itemize}
\indent Системски позиви се извршавају без посредства \textit{Valgrind}-а, зато што језгро \textit{Valgrind}-а не може да прати њихово извршавање у самом језгру оперативног система.


\subsection{Транслација}

\indent У наставку су описани кораци које \textit{Valgrind} извршава приликом анализе програма. Постоји осам фаза транслације. Све фазе осим инструментацје коју обавља алат \textit{Valgrind}-а, обавља језгро \textit{Valgrind}-а.

\begin{itemize}
  \item \textbf{ Дисасемблирање } - процес превођења машинског кода у еквивалетни асемблерски код. \textit{Valgrind} врши превођење машинског кода у интерни скуп инструкција која се називају међукод инструкције. Међукод представља редуковани скуп инструкција (скр. енг. \textit{RISC}). Ова фаза је зависна од архитетктуре на којој се извршава.
  \item \textbf{ Оптимизација 1} - Прва фаза оптимизације линеаризује \textit{IR} репрезентацију. Примењују се неке стандардне оптимизације програмских преводилаца као што су уклањање редудантног кода, елиминација подизраза, једноставно одмотавање петљи и сл.
  \item \textbf{ Инструментација} - Блок кода у \textit{IR} репрезентацији се прослеђује алату, који може произвољно да га трансформише. Приликом инструментације алат у задати блок додаје додатне \textit{IR} операције, кјима проверава исправност рада програма.
  \item \textbf{ Оптимизација 2 } - Друга фаза оптимизације је једноставније од прве, укључује множење констати и уклањање мртвог кода.
  \item \textbf{ Градња стабла } - Линеаризована \textit{IR} репрезентација се конвертује натраг у стабло ради лакшег избора инструкција.
  \item \textbf{ Одабир инструкција } - Стабло \textit{IR} репрезентације се конвертује у листу инструкција које користе виртуалне регистре. Ова фаза се такође разликује у зависности од архитеткуре на којој се извршава. 
  \item \textbf{ Алокација регистара} - Виртуални регистри се замењују стварним. По потреби се уводе пребацивања у меморију. Независна је за платформу, користи позив функција које налазе из који се регистара врши читање и у које се врши упис.
  \item \textbf{ Асемблирање } - Изабране инструкције се енкодују на одговарајући начин и смештају у блок мемроји. Ова фаза се такође разликује у зависноти од архитектуре на који се изршава. ~\cite{SeeMIPSRun}
\end{itemize}

\section{Memcheck}

\indent Меморијске грешке често се најтеже детектују, а самим тим и најтеже отклањају. Разлог томе је што се такви проблеми испољавају недетерминистички и није их лако репродуковати. \textit{Memcheck} је алат који детектује меморијске грешке корисничког програма. Како не врши анализу изворног кода већ машинског, \textit{Memcheck} има могућност анализе програма писаног у било ком језику.

\indent За програме писане у језицима C и C++ детектује следеће уобичајне проблеме:
\begin{itemize}
  \item Приступање недопуштеној меморији, на пример преписивање блокова на хипу, преписивање врха стека и приступање меморији која је већ ослобођена.
  \item Коришћење недефинисаних вредности, вредности које нису иницијализоване или које су изведене од других недефинисаних вредности.
  \item Неисправно особађање хип меморије, као што је дупло ослобађање хип блокова или неупареног коришћења фукнција \textit{malloc/new/new[]} и \textit{free/delete/delete[]}.
  \item Преклапање параметара прослеђених функцијама (нпр. преклапање \textbf{\textit{src}} и \textbf{\textit{dst}} показивача код фукнције \textbf{\textit{memcpy}}.
  \item Цурење меморије.
\end{itemize}

\indent Пуштање преведеног програма кроз \textit{Valgrind}, врши се извршавањем следеће линије у терминалу:

\begin{center}
 valgrind -\--tool=memcheck ./main
\end{center}

\indent -\--tool = опција одређује који алат ће \textit{Valgrind} пакет користити. Програм који ради под контролом \textit{Memcheck}-a je обично 20 до 100 пута спорији него када се извршава самостално, због транслације кода. Излаз програм је повећан за излаз који додаје сам алат \textit{Memcheck}, који се исписује на стандардном излазу за грешке.



\subsection{Коришћење неиницијализованих вредности}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika1.png}
\end{center}
\caption{Пример програма main.c}
\label{fig:main}
\end{figure}

\indent На слици \ref{fig:main} је дат пример програма у коме користимо неиницијализовану променљиву. Грешка о коришћењу неиницијализоване вредности се генерише када програм користи променљиве чије вредности ниси иницијализоване, другим речима недефинисане.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika2.png}
\end{center}
\caption{Детектција неиницијализованих вредности}
\label{fig:memcheck}
\end{figure}

\indent Слика \ref{fig:memcheck} приказује излаз \textit{Valgrind}-а који детектује коришћење недефинисаних вредности у програму. Први део, односно пре три линије се штампају приликом покретања било ког алата који је у склопу \textit{Valgrind}-а, у овом случају \textit{Memcheck}. Следећи део нам показује поруке о грешкама које је \textit{Memcheck} пронашао у програму. Последња линија приказује суму свих грешака које је алат пронашао и штампа се по завршетку рада. \\
\indent На овој слици је приказан излаз из \textit{Valgrind}-а када се открије  коришћење недефинисаних вредности. У програму недефинисана променљива може више пута да се копира, \textit{Memcheck} прати све то, бележи податке о томе, али не пријављује грешку. У случају да се недефинисане вредности користе на начин да од те вредности зависи даљи ток програма или ако је потребно приказити вредности недефинисане промељиве, \textit{Memcheck} пријављује грешку. да би могли да видимо главни извор коришћења недефинисаних вредности у програму, додаје се опција \textit{-\--trace-origins=yes}.

\subsection{Коришћење неиницијализоване или неадресиране вредности у сисстемсом позиву}

\indent \textit{Memcheck} прати све параметре системског позива:
 
\begin{itemize}
  \item Проверава све параметре појединачно, без обзира да ли су иницијализовани.
  \item Проверава да ли системски позив треба да чита из меморије која је дефинисана у програму. \textit{Memcheck} проверава да ли је цела меморија адресирана и иницијализована.
  \item Ако системски позив треба да пише у меморију, \textit{Memcheck} проверава да ли је та меморија адресирана.
\end{itemize}

\indent После системског позива \textit{Memcheck} прецизно ажурира иноформације о промени у меморији које су постављене у системског позиву.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika3.png}
\end{center}
\caption{Пример програма main1.c}
\label{fig:main1}
\end{figure}

\indent На слици \ref{fig:main1} дат је пример позива системског позива са неисправним параметрима.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika4.png}
\end{center}
\caption{Пример излаза за програм main1.c}
\label{fig:memcheck1}
\end{figure}

\indent На слици \ref{fig:memcheck1} је извештај који даји добијамо након анализе програма main1.c. Можемо да видимо да је \textit{Memcheck} приказао информације о коришћењу неиницијализованих вредности у системским позивима. Прва грешка приказује да параметар \textit{buf} системског позива \textit{write()} показује на неиницијализовану вредност. Друга грешка приказује да је податак који се прослеђује системског позиву \textit{exit()} недефинисан. Такође, приказане су и линије у самом програму где се ове вредности користе.

\subsection{Недопуштено особађање меморије}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika5.png}
\end{center}
\caption{Пример програма main2.c}
\label{fig:main2}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika6.png}
\end{center}
\caption{Пример излаза за програм main2.c}
\label{fig:memcheck2}
\end{figure}

\indent На слици \ref{fig:main2} дат је пример програма у коме се нелегално ослобађа меморија. \textit{Memcheck} прати свако алоцирање меморије које програм направи употребом функција \textit{malloc/new}, тако да он увек поседује информацију да ли су аргументи који се прослеђују функцијама \textit{free/delete} легитимни или не. У нашем примеру, програм ослобађа исту меморијску зону два пута. Извештај о недопуштеном ослобађању меморије приказан је на слици \ref{fig:memcheck2}.

\indent \textit{Memcheck} је пријавио да је програм покушао два пута да ослободи неку меморијску зону.  Такође, \textit{Memcheck} ће нам пријавити и ако програм покуша да ослободи меморијску зону преко показивача који не показује на почетак динамичке меморије.

\subsection{Детекција цурења меморије}

\indent \textit{Memcheck} бележи податке о свим динамичким блоковима који су алоцирани током извршавања програма позивом функција \textit{malloc(), new()} и др. Када програм прекине са радом, \textit{Memcheck} тачно зна колико меморијских блокова није ослобођено.

\indent Ако је опција \textit{-\--leak-check} адекватно подешена, за сваки неослобођени блок \textit{Memcheck} одређује да ли је могуће приступити том блоку преко показивача.

\indent Постоје два начина да приступимо садржају неког меморијског блока преко показивача. Први начин је преко показивача који показује на почетак меморијског блока. Други начин је преко показивача који показује на садржај унутар меморијског блока.

\indent Постоји неколико начина да сазнамо да ли постоји показивач који показује на унутрашњост неког меморијског блока:
\begin{itemize}
  \item Постојао је показивач који је иницијално показивао на почетак блока, али је намерно (или ненамерно) померен да показује на унутрашњост блока.
  \item Ако постоји нежељена вредност у меморији, која је у потпуности неповезана и случајна.
  \item Ако постоји показивач на низ C++ објеката (који поседују деструкторе) који су алоцирани са \textit{new[]}. У овом случају, неки компајлери чувају "магични показивач" који садржи дужину низа од почетка блока.
\end{itemize}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika7.png}
\end{center}
\caption{Пример показивача на меморијски блок}
\label{fig:memblok}
\end{figure}

\indent На слици \ref{fig:memblok} је приказано 9 могућих случајева када показивачи показују на неке меморијске блокове. Сваки могући случај када показивач показује на неки меморијски блок може се представити са једним од приказаних 9 случајева. \textit{Memcheck} обједињује неке од ових случајева, тако да добијамо наредне четири категорије.

\begin{itemize}
  \item "Још увек доступан". Ово покрива примере 1 и 2 на слици \ref{fig:memblok}. Показивач који показује на почетак блока или више показивача који показују на почетак блока су пронађени. Зато што постоје показивачи који показују на меморијску локацију која није ослобођена, програмер може да ослободи меморијску локацију непосредно пре завршетка извршавања програма.
  \item "Дефининитивно изгубљен". Ово се односи на трећи случај на слици \ref{fig:memblok}. Ово значи да је немогуће пронаћи показивач који показује на меморијску блок. Блок је проглашен изгубљеним, заузета меморија не може да се ослободи пре завршетка програма, јер не постоји показивач на њу.
  \item "Индиретно изгубљен". Ово покрива случајеве 4 и 9 на слици \ref{fig:memblok}. Меморијски блок је изгубљен, не зато што не постоји показивач који показује на њега, него зато што су сви блокови који указују на њега изгубљени. На пример, ако имамо бинарно стабло и корен је изгубљен, сва деца чворови су индиректно изгубљени. С обзиром на то да ће проблем нестати ако се порави показивач на дефинитивно изгубљен блок који је узроковао индиректно губљење блока, \textit{Memcheck} неће пријавити ову грешку уколико није укључена опција \textit{-\--show-reachable=yes}.
  \item "Могуће изгубљен". Ово су случајеви од 5 до 8 на слици \ref{fig:memblok}. Пронађен је један или више више показивача на меморијски блок,  али најмање један од њих показује на унутрашњост меморијског блока. То може бити само случајна вредност у меморији која показује на унутрашњост блока, али ово не треба сматрати у реду док се не разреши случај показивача који показује на унутрашњост блока.
\end{itemize}

\indent Ако постоји забрана приказивања грешке за одређени меморијски блок, без обзира којој од горе поменутих категорија припада, на неће бити приказана.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika8.png}
\end{center}
\caption{Резиме цурења меморије}
\label{fig:memcurenje}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika9.png}
\end{center}
\caption{Извештај о цурењу меморије}
\label{fig:memizv}
\end{figure}


\indent На слици \ref{fig:memcurenje} је дат резиме цурења меморије који исписује \textit{Memcheck}. Ако је укључена опција \textit{-\--leak-check=yes}, \textit{Memcheck} ће приказати детаљан извештај о сваком дефинитивно или могуће изгубљеном блоку,  као и о томе где је он алоциран. \textit{Memcheck} нам не може рећи када, како или зашто је неки меморијски блок изгубљен. Генерано, програм не треба да има ниједну дефинитвно или могуће изгубљен блок на излазу.

\indent На слици \ref{fig:memizv} је приказан извештај који нам даје \textit{Memcheck} о дефинитивном губитку два блока величине 16 и 19 бајта, као линију у програму где су они алоцирани.

\indent Због постојања више типова цурења меморије поставња се питање које цурење меморије на излазу из програма треба да посматрамо као "грешку", а коју не. \textit{Memcheck} користи следећи критеријум:

\begin{itemize}
  \item \textit{Memcheck} сматра да је цурење меморије "грешка" само ако је укључена опција \textit{-\--leak-check=full}. Другим речима, ако подаци о цурењу меморије нису приказани, сматра се да то цурење није "грешка".
  \item Дефинитивно и могуће изгубљени блокови се сматрају за праву "грешку", док индиректно изгубљени и још увек доспуни блокови се не сматрају као грешка.
\end{itemize}


\section{Cachgrind}

\indent \textit{Cachgrind} је алат који симулира и прати приступ скривеној меморји машине на којој се програм, који се анализира, извршава. Он симулира скривену меморију машине, која има први ниво скривене меморије подељен у две одвојене независне секције: \textit{I1} - секција брзе меморије у кој се смештају инструкције и \textit{D1} - секција брзе меморије у којој се смештају подаци. Други ниво скривене меморије коју \textit{Cachgrind} симулира је обједињен - \textit{L2}. Овај начин конфигурације одговара многим модерним машинама.

\indent Постоје машине које имају и трећи ниво брзе меморије \textit{I3}. У том случају, \textit{Cachgrind} симулира приступ трећем нивоу. Генерално гледано, \textit{Cachgrind} симулира  \textit{L1}, \textit{D1} и \textit{LL} (последњи ниво скривене меморије).

\indent \textit{Cachgrind} прикупља следеће статистичке податке о програму који анализира (скраћенице које се користе даље у тексту су дате у заградама):

\begin{itemize}
  \item \textit{I} читање брзе меморије ( \textit{Ir}, што представља број извршених инструкција), \textit{I1} број промашаја читања (\textit{I1mr}) и број промашаја читања инструкција нивоа \textit{LL} брзе меморије (\textit{ILmr}).
  \item \textit{D} читање брзе меморије (\textit{Dr}, што је једнако броју читања меморије), \textit{D1} број промашаја читања (\textit{D1mr}, и број промашаја читања података нивао \textit{LL} брзе меморије (\textit{DLmr}).
  \item \textit{D} писања у брзу меморију (\textit{Dw}, што је једнако броју писања у меморију), \textit{D1} број промашаја писања у брзу меморију и број промашаја писања података у нивоу \textit{LL} брзе меморије (\textit{DLmw}).
  \item Број условно извршених грана (\textit{Bc}) и број промашаја условно извршених грана (\textit{Bcm}).
  \item Број индиректно извршених грана (\textit{Bi}) и број промашаја индиректно извршених грана (\textit{Bim}).
\end{itemize}

\indent Приметимо да је број приступа \textit{D1} делу брзе меморије једнак збиру \textit{D1mr} и \textit{D1mw}, док је укупан број приступа нивоу \textit{LL} једнак збиру  \textit{ILmr}, \textit{DLmr} и \textit{DLmw} број приступа. Ова статистика се прикупља на нивоу целог програма, као и за појединачно на нивоу функција. Може се такође, добити и број приступа скривеној меморији за сваку линију кода у оригиналном програму. На модерним машинама \textit{L1} промашај кошта око 10 процесорских циклуса, \textit{LL} промашај кошта око 200 процесорских циклуса, а промашаји условно и инидиректно извршене гране од 10 до 30 процесорских циклуса.

\subsection{Коришћење Cachgrind-a}

\indent На почетку коришћења алата \textit{Cachgrind}, програм који желимо да анализирамо покрећемо самим \textit{Cachgrind}-ом. На тај начин прикупљамо информације које су нам потребне за касније профилисање кода. Затим покрећемо алат \textit{cg\_annotate} у оквиру пакета \textit{Valgrind} који нам приказује детаљан извештај о програму који анализирамо са \textit{Cachgrind}-ом. Опционо, можемо да користимо алат \textit{cg\_merge} да сумирамо у једну датотеку више излаза које смо добили вишеструким покретањем \textit{Cachgrind}-а над истим програмом. Ту датотетку касније користимо као улаз у \textit{cg\_annotate}. Такође, можемо да користимо алат \textit{cg\_diff} који прави разлику између више излаза из алата \textit{Cachgrind}, које касније користимо као улаз у алат \textit{cg\_annotate}

\indent Покретање самог алата \textit{Cachgrind} врши се извршавањем следеће линије у терминалу:

\begin{center}
 valgrind -\--tool=cachgrind ./main
\end{center}


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika10.png}
\end{center}
\caption{Извештај алата \textit{Cachgrind}}
\label{fig:cachgrind}
\end{figure}

\indent Извршава програма кроз \textit{Cachgrind} траје веома споро. Након завршетка рада, добијају се статитстике као што је приказано на слици \ref{fig:cachgrind}.

\subsection{Cachgrind метаподаци}

\indent У наставку су описани метаподаци који се чувају у структурама.

\indent \textbf{Глобално стање брзе меморије}. Прва структура која се налази у склопу \textit{Cachgrind} метаподатака је глобано стање брзе меморије. Она представља три дела симулиране брзе меморије (\textit{L1}, \textit{D1},  \textit{LL}). Њене вредности се освежавају приликом извршене сваке инструкције програма чија се брза меморија симулира, тачније, приликом позива функције које симулирају приступ брзој меморији циљне платформе. Функцијама се прослеђују информациј ео приступу брзој меморији, као што су адресе и величина меморије којој се приступа.

\indent Симулација приступа брзој меморији има следеће карактеристике:

\begin{itemize}
  \item Када се деси помашај уписа у брзу меморију, блок који је потребно уписати се семпта у \textit{D1} део брзе меморије. 
  \item Инструкције које содификују врдност меморије третирају се као читање брзе меморије. Наиме, инструкције које мењају садржај брзе меморије најпре читају садржај брзе меморије, модификују вредност и снимају нову вредност. Самим тим, упис у брзу меморију не може да изсазове промашај, јер је гарантован успешним читањем. Такође, циљ \textit{Cachgrind}-а није да прикаже колико пута се приступа брзој меморији, већ да прикаже број промашаја приступа брзој меморији.
   \item Линија у брзој меморији, којој одговара садржај у меморији са директним приступом, одређује се као \textit{ (M + N - 1) }, где је величина линије = 2\^M бајта, (величина брзе меморије / величина линија) = 2\^N бајта.
   \item \textit{L2} део брзе меморије реплицира све уносе у \textit{L1} део брзе меморије.
   \item Онај блок у брзој меморији који се најмање користи ће бити избачен из брзе меморије уколико је потребно убацити нови блок података у брзу меморију.
   \item Са референцама које показују на две линије у кеш меморији рукује се на следећи начин:
   	\begin{itemize}
   		\item уколико су пронађена оба блока у брзој меморији, рачунамо сам оједан погодат;
   		\item уколико један блок нађемо у брзој меморији, а други не, рачунамо један промашај (и нула погодатака);
   		\item уколико оба блока не пронађемо у брзој меморији, рачунамо један промашај (не два).
   	\end{itemize}
\end{itemize}

\indent Параметри симулиране брзе меморије (величина брзе меморије, величина линије и асоцијативност) одрешују се на један од два начина. Први наин је потребом \textit{cpuid} наредбе. Други начин представља ручно унопење параметара симулиране брзе меморије, прикиком покретања самог \textit{Cachgrind}.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika11.png}
\end{center}
\caption{Структура централне табеле трошкова}
\label{fig:tabelaTroskova}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika12.png}
\end{center}
\caption{Структура табеле информација о инструкцијама}
\label{fig:infoInstr}
\end{figure}

\indent \textbf{Централна табела трошкова}. Друга структура која чини метаподатке алата \textit{Cachgrind} је централна табнела трошкова. Свака линија укоду која се инструментализује, алоцира једну овакву табелу у коју смешта податке о приступу брзој меморији, броју погодака и промашаја приступа брзој меморији, који се дешавају приликом извршавања саме линије кода. На слици \ref{fig:tabelaTroskova} приказане су структуре које представљају ценстралну табелу трошкова. \textit{ULong} је 64-битна целобројна вредност. Узимамо 64-битну вредност, јер број приступа може да буде већи него што може да се представи 32-битном целобројном вредношћу. У \textit{CC} структури \textit{m1} и \textit{m2} представљају број промашаја за \textit{L1} и \textit{LL} део скривене меморије. Структура \textit{lineCC} садржи три \textit{CC} елемента: за читање \textit{I} дела, за читање дела \textit{D} и за писање у део \textit{D} скривене меморије. Поље \textit{next} је потребно јер је централна табела трошкова представљена као променљива \textit{"heš"} табела. Поље \textit{line} представља број линије у коду која одговоара тој табели трошкова. Сам број линије није довољан да би се пронашла линија у коду којој одговара централна табела трошкова (име фајла је потребно). У пракси, то значи централна табела трошкова има три новоа: трошкови су груписани по имену фајла, затим по имену функције и на крају по броју линије.


\indent \textbf{Табела информација о инструкцијама}. Трећа структура која чини метаподатке алата \textit{Cachgrind} је табела информација о инструкцијама. Она се користи за чување непроменљивих информација о самим инструкцијама током самог процеса инструментације. На овај начин се смањује величина додатог кода којим се анализира код. Повећава се брзина извршавања самог алата, јер се самњује број аргумената који се просеђују функцијама, које врше симулацију приступа број меморији.


\indent Свакој инструментализованој инструкцији додељује се по једно поље у табели информација о инструкцијама, које садржи структуру \textit{instr \_info},  приказаној на слици \ref{fig:infoInstr}. Поље \textit{instr\_addr} представља адресу инструкције \textit{instr\_size} представља величину инструкције изражену у бајтовима, \textit{data\_size} чува величину података коме инструкција приступа (0 уколико инструкција не приступа меморији) и \textit{parent} показује на поље у табели трошкова за исту линију кода одакле је инструкција изведена.

\subsection{Инструментација}

\indent Први корак приликом инструментације кода односи се на пролаз кроз све основне блокове појединачно ради пребројавања инструкција које се налазе у њима. На основу овог броја се креира листа \textit{instr \_info} елемената, при чему сваки елемент листе одговара једној инструкцији у основном блоку.

\indent У другом пролазу, \textit{Cachgrind} врши категоризацију оригиналних инструкција, \textit{Cachgrind} дели инструкције у следеће категорије:

\begin{itemize}
  \item Инструкције које не приступају меморији, нпр. \textit{move \$t3, \$a0}
  \item Инструкције које читају садржај меморије, нпр. \textit{lw \$t3, 4(\$a0}
  \item Инструкције које уписују садржај регистара у меморију, нпр. \textit{sw \$t3, 4(\$a0)}
  \item Инструкције које модификују садржај меморијске локације
  \item Инструкције које читају садржај из једне меморијске локације и тај садржај уписују у другу меморијску локацију.
\end{itemize}

\indent Свака инструкција система базираног на \textit{MIPS} процесорима је растављена на више \textit{UCode} инструкција, тако да \textit{Cachgrind} одређује којој категорији оригинална инструкција припада на основу \textit{LOAD} и \textit{STORE} \textit{UCode} инструкција. \textit{Cachgrind} чита инфромације које помажу при отклаљању грешака. На основу ових информација он креира елементе \textit{lineCC} у централној табели трошкова. Затим иницијализује одређене \textit{instr \_info} елементе у  низ који је иницијализован за сваки основни лбок појединачно (где је н-ти елемент \textit{instr \_info} одговара н-тој инструкцији у основном блоку). Када је иницијализовао све елементе \textit{lineCC} и \textit{instr \_info} алат \textit{Cachgrind} извршава процес инструментализације кода који се састоји из позива одговарајућих \textit{C} функција, које симулирају приступ брзој меморији циљне платформе. Која \textit{C} функција ће бити позвана зависи од категорије којој инструкција припада. Постоје само четири врста \textit{C} функција које симулирају приступ брзој меморији, јер функције које припадају другој и четврој категорији позивају исту \textit{C} функцију за симулирање приступа брзој меморији. Број параметара који се прослеђује \textit{C} функција се, одређује на основу категорије којој та функција припада.

\subsection{Приказ статистичких информација}

\indent Приликом завршетка анализе програма \textit{Cachgrind} похрањује прикупљену табелу тропкова у датотеку која се назива \textit{cachgrind.out.pid}; при чему \textit{pid} представља јединстевени идентификатор процеса који се извршио. Алат групише све трошкове по фајловима и функцијама којима ти трошкови припадају. Глобална статистика се рачуна накнадно, приликом приказа резултата. На овај начин се штеди јако пуно времана приликом анализе кода. Функције које симулирају приступ брзој меморији се позивају јако често, тако да би додавање још неколико инструкција које сабирају , знатно успорило и овако споро извршавање алата.

\section{Helgrind}



\section{Callgrind}


\section{Massif}



\section{DRD}

\chapter{FPXX}
\label{chp:fpxx}

\chapter{Закључак}

% ------------------------------------------------------------------------------
%\pangrami

%\pangrami

% ------------------------------------------------------------------------------
% Literatura
% ------------------------------------------------------------------------------
\literatura

% ==============================================================================
% Završni deo teze i prilozi
\backmatter
% ==============================================================================

% ------------------------------------------------------------------------------
% Biografija kandidata
\begin{biografija}
\textbf{Вук Стефановић Караџић} (\emph{Тршић, 26. октобар/6. новембар
  1787. — Беч, 7. фебруар 1864.}) био је српски филолог, реформатор
српског језика, сакупљач народних умотворина и писац првог речника
српског језика.  Вук је најзначајнија личност српске књижевности прве
половине XIX века. Стекао је и неколико почасних доктората.
Учествовао је у Првом српском устанку као писар и чиновник у
Неготинској крајини, а након слома устанка преселио се у Беч,
1813. године. Ту је упознао Јернеја Копитара, цензора словенских
књига, на чији је подстицај кренуо у прикупљање српских народних
песама, реформу ћирилице и борбу за увођење народног језика у српску
књижевност. Вуковим реформама у српски језик је уведен фонетски
правопис, а српски језик је потиснуо славеносрпски језик који је у то
време био језик образованих људи. Тако се као најважније године Вукове
реформе истичу 1818., 1836., 1839., 1847. и 1852.
\end{biografija}
% ------------------------------------------------------------------------------

\end{document} 