% Format teze zasnovan je na paketu memoir
% http://tug.ctan.org/macros/latex/contrib/memoir/memman.pdf ili
% http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf
% 
% Prilikom zadavanja klase memoir, navedenim opcijama se podešava 
% veličina slova (12pt) i jednostrano štampanje (oneside).
% Ove parametre možete menjati samo ako pravite nezvanične verzije
% mastera za privatnu upotrebu (na primer, u b5 varijanti ima smisla 
% smanjiti 
\documentclass[12pt,oneside]{memoir}

% Paket koji definiše sve specifičnosti mastera Matematičkog fakulteta
\usepackage{matfmaster}
%
% Podrazumevano pismo je ćirilica.
%   Ako koristite pdflatex, a ne xetex, sav latinički tekst na srpskom jeziku
%   treba biti okružen sa \lat{...} ili \begin{latinica}...\end{latinica}.
%
% Opicija [latinica]:
%   ako želite da pišete latiniciom, dodajte opciju "latinica" tj.
%   prethodni paket uključite pomoću: \usepackage[latinica]{matfmaster}.
%   Ako koristite pdflatex, a ne xetex, sav ćirilički tekst treba biti
%   okružen sa \cir{...} ili \begin{cirilica}...\end{cirilica}.
%
% Opcija [biblatex]:
%   ako želite da koristite reference na više jezika i umesto paketa
%   bibtex da koristite BibLaTeX/Biber, dodajte opciju "biblatex" tj.
%   prethodni paket uključite pomoću: \usepackage[biblatex]{matfmaster}
%
% Opcija [b5paper]:
%   ako želite da napravite verziju teze u manjem (b5) formatu, navedite
%   opciju "b5paper", tj. prethodni paket uključite pomoću: 
%   \usepackage[b5paper]{matfmaster}. Tada ima smisla razmisliti o promeni
%   veličine slova (izmenom opcije 12pt na 11pt u \documentclass{memoir}).
%
% Naravno, opcije je moguće kombinovati.
% Npr. \usepackage[b5paper,biblatex]{matfmaster}

% Pomoćni paket koji generiše nasumičan tekst u kojem se javljaju sva slova
% azbuke (nema potrebe koristiti ovo u pravim disertacijama)
\usepackage{pangrami}

% Datoteka sa literaturom u BibTex tj. BibLaTeX/Biber formatu
\bib{matfmaster-primer}

% Ime kandidata na srpskom jeziku (u odabranom pismu)
\autor{Aлександра Караџић}
% Naslov teze na srpskom jeziku (u odabranom pismu)
\naslov{Алат \textit{Valgrind} - имплементација конвенције \textit{FPXX} за архитектуру \textit{MIPS} }
% Godina u kojoj je teza predana komisiji
\godina{2017}
% Ime i afilijacija mentora (u odabranom pismu)
\mentor{др Милена \textsc{Вујошецић Јаничић}, доцент\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija prvog člana komisije (u odabranom pismu)
\komisijaA{др Филип \textsc{Марић}, ванредни професор\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija drugog člana komisije (u odabranom pismu)
\komisijaB{др Јелена \textsc{Граовац}, доцент\\ Универзитет у Београду, Математички факултет}
% Ime i afilijacija trećeg člana komisije (opciono)
% \komisijaC{}
% Ime i afilijacija četvrtog člana komisije (opciono)
% \komisijaD{}
% Datum odbrane (obrisati ili iskomentarisati narednu liniju ako datum odbrane nije poznat)
\datumodbrane{15. јануар 2016.}

% Apstrakt na srpskom jeziku (u odabranom pismu)
\apstr{%
%\pangrami
}

% Ključne reči na srpskom jeziku (u odabranom pismu)
\kljucnereci{анализа, геометрија, алгебра, логика, рачунарство, астрономија}

\begin{document}
% ==============================================================================
% Uvodni deo teze
\frontmatter
% ==============================================================================
% Naslovna strana
\naslovna
% Strana sa podacima o mentoru i članovima komisije
\komisija
% Strana sa posvetom (u odabranom pismu)
\posveta{Деди}
% Strana sa podacima o disertaciji na srpskom jeziku
\apstrakt
% Sadržaj teze
\tableofcontents*

% ==============================================================================
% Glavni deo teze
\mainmatter
% ==============================================================================

% ------------------------------------------------------------------------------
\chapter{Увод}
% ------------------------------------------------------------------------------
%\pangrami

%\section{Примери коришћења класичних \LaTeX{} елемената}

% primer korišćenja tabele
%\begin{table}
%\centering
%\caption{Резултати}
%\label{tbl:rezultati}
%\begin{tabular}{c>{\centering}p{2cm}c}
%\toprule
%1 & 2 & 3\\\midrule
%4 & 5 & 6\\\cmidrule(rl){1-2}
%7 & 8 & 8\\
%\bottomrule
%\end{tabular}
%\end{table}

% primer korišćenja slike
%\begin{figure}[!ht]
%  \centering
%  \includegraphics[width=0.5\textwidth]{graph.png}
%  \caption{Графикон}
%  \label{fig:grafikon}
%\end{figure}

% primer jednostavnije matematičke formule
%Ево и један пример математичке формуле: $e^{i\pi} + 1 = 0$. 
% primer referisanja na sliku
%На слици \ref{fig:grafikon} приказан је један графикон.

% primer kompleksnije matematičke formule
%$$
%\int_a^b f(x)\ \mathrm{d}x \ =_{def}\ \lim_{\max{\Delta x_k \rightarrow 0}} \sum_{k=1}^n f(x_k^*)\Delta x_k
%$$

% primer referisanja na poglavlja i strane poglavlja
%Више детаља биће дато у глави \ref{chp:razrada} на страни \pageref{chp:razrada}.

% primer liste
%Можемо правити и набрајања:
%\begin{enumerate}
%\item Анализа 1
%\item Линеарна алгебра
%\item Аналитичка геометрија
%\item Основи програмирања
%\end{enumerate}

%\pangrami

% ------------------------------------------------------------------------------
\chapter{Архитектура \textit{MIPS}}
\label{chp:mips}
% ------------------------------------------------------------------------------
\subsection{\textit{CISC} и \textit{RISC}}

\indent Термин архитекуре у рачунарству се користи да опише апстрактну машину која се програмира, а не стварну имплементацију те машине. Архитектура процесора у суштини дефинише скуп инструкција и регистара. Архитекрура и скуп инструкција се једним именом називају ISA (скр. \textit{Instruction Set Architecture}) ~\cite{SeeMIPSRun}.

\subsection{MIPS}
\indent MIPS је најелегантнија архитектура међу свим активним RISC архитектура, чак и по мишљењу конкуренције. Елеганција није довољна да би се освојило тржиште, али MIPS микропорцесори су успели бити међу најефикаснији сваком генерацијом остајући међу најједноставнијима.
MIPS процесори је један од RISC процесора, рођеног у плодном периоду академских истраживања и развоја. RISC  (енг. \textit{Reduced Instruction Set Computing}) је атрактивни акроним, 
~\cite{SeeMIPSRun}

\section{Регистри у MIPS-у}

\indent Регистри представљају малу, веома брзу меморију, која је део процесора. MIPS процесори могу вршити операције само над садржајима регистара и специјалним константама које су део инструкције. \\
\indent У MIPS архитектури, постоји 32 регистара опште намене. Само два регистара се понашају другачије од осталих регистара:

\begin{description}
  \item[\$0] - Увек враћа нулу, без обзира коју му се вредност додели
  \item [\$31] - Увек се користи за адресу повратка из функције на коју се скочи инструкцијом \textit{jal}
\end{description}
Сви ови регистри су идентични и могу се користити за било коју истрикцију (може се чак користити и регистар \$0 као дестинација, мада ће резултат да нестане). 

Регистри опште намене су описани у наставку:
\begin{description}
  \item[at] - Резервисан за псеудоинструкције које асемблер генерише
  \item[v0, v1] - Користи се за враћање резултата при повратку из неке функције. Резултат може бити целобројног типа или број записан у фиксном зарезу.
  \item[а0 - а3] - Користи се за прослеђивање прва 4 аргумената функције која се позива
  \item[t0 - t9] - по конвенцији која је описана 
  \item[s0 - s7] - по конвенцији која је описана 
  \item[k0, k1] - Резервисано за систем прекида, који након коришћења не враћа садржај ових регистара на почетни. Како се прекид не позива из програма који се тренутно извршава, нема примене позивне конвенције. То значи да се садржај регистара које прекинути програм користи може пореметити. Због тога, систем прекида прво сачува саджаје регистара опште намене, који су важни за програм који се у том тренутку извршавао, и чији садржај планира да мења. У те сврхе се користе ови регистри.
  \item[gp] - Користи се у различите сврхе. У коду који  не зависи од позиције (енг. \textit{Position Independent Code} скраћено PIC), свом коду и подацима се пристпуа преко табеле показивача, познате као GOT (скраћено од енг. \textit{Global Offset Table}). Регистар \textit{\$gp} показује на ту табелу. PIC је код који се може извршавати на било којој меморијској адреси, без модификација. PIC се најчешће користи за дељење библиотеке, при чему се заједнички код библиотеке може учитати у одговарајуће локације адресних простора различитих програма који је користе. \\
  У регуларном коду који зависи од позиције, регистар \textbf{\$gp} се користи као показивач на средину у статичкој меморији. То значи да се подацима који се налазе 32 КВ лево или десно од адресе која се налази у овом регистру може приступити помоћу једне инструкције. Дакле, инструкције \textit{load} и \textit{store} које се користе за учитавање, односно складиштење података, се могу извршити у само једној инструкцији, а не у две као што је иначе случај. У пракси се на ове локације смештају глобали подаци који не заузимају много меморије. Оно што је битно је да овај регистар не користи сви системи за компилацију и сва окружења за извршавање.
  
  \item[sp] - Показивач на стек. Оно што је битно је да стек расте наниже. Потребне су специјалне инструкције да би се показивач на стек повећао и смањио, тако да \textit{MIPS} ажурира стек само при позиву и повратку из фукције, при чему је за то одговорна функција која је позвана. \textit{sp} се при уласку у функцију прилагођава на најнижу тачку на стеку којој ће да приступати у функцији. Тако ј еомогућено да компилатор може да приступи поменљивама на стеку помоћу константног помераја у односу на \textit{\$sp}.
  \item[fp] - Познат и као \textit{\$s8}, показивач на стек оквир. Користи се од стране функције, за праћење стања на стеку, за случај да из неког разлога компилатор или програмер не могу да израчунају померај у односу на \textit{\$sp}. То се може догодити уколико програм врши проширење стека, при чему се вредност проширења рачуна у току извршавања. Ако се дно стека не може израчунати у току превођења, не може се приступити променљивама помоћу \textit{\$sp}, па се на почетку функције \textit{\$fp} иницијализује на константну позицију која одговара стек оквиру функције. Ово је локално за функцију.
  \item[ra] - Ово је подразумевани регистар за смештање адресе воратка и то је подржано кроз одговарајуће инструкције скока. Ово се разлицкује од конвеција које се корсите на архитеткурама џ86, где инструкција позива функције адресз повратка смешта на стек. При уласку у фукцију регистар \textit{ra} обично садржи адресу повратка фукције, тако да се функције углавном завршавају инструкцијом \textit{jr \$ra}, али у принципу, може се користити и неки други регистар. Због неких оптимизација које врши процесор, препоручује се коришћење регистара \textit{\$ra}. Функције које позивају друге функције морају сачувати садржај регистара \textit{\$ra}.
\end{description}


\indent Постоје два специјална регистра \textit{Hi} и \textit{Lo}, који се користе само при множењу и дељењу. ово нису регистри опште намене, те се не користе при другим инструцијама. Не може им се приступити директно, већ постоје специјалне инструкције \textit{mfhi} и \textit{mflo} за премештање садршаја ових регистара. Инструкција \textit{mfhi} је облика \textit{mfhi rd}, и она премешта садржај регистар \textit{Hi} у регистар \textit{rd}, док инструкција \textit{mflo} премешта садржај регистара \textit{Lo}.


\section{Floating point регистри у MIPS-у}

MIPS архитектура користи два формата FP (скр. \textit{Floating Point}) препоручена од стране IEEE 754:

\begin{itemize}
	\item \textit{Једнострука прецизност} (eнг. \textit{Single precision}) - Користи се 32 бита за чување у меморији. MIPS компајлери користе једноструку прецизност за променљиве типа \textit{float}
	\item \textit{Двострука прецизност} (eнг. \textit{Double precision}) - Користи се 64 бита за чување у меморији. C компајлери коисте двоструку прецизност за C \textit{double} типове података.
\end{itemize}

\indent Начин да се две речи ширине 32 бита се смештају у меморију као једна реч ширине од 64 бита је начин смештања у меморији (виша половина битова прво, или нижа половина битова прво) и зависи од начина смештања у меморији. 

\indent Стандартд IEEE 754 је веома захтеван и поставио је два велика проблема. Први, омогућавање детекције неуобичајних резултата доводи проточну обраду (енг. \textit{pipeline}) тешком. Постоји опција да се имплементира IEEE механизам сигнализирања изузетака, али је проблем да се детектују случајеви када хардвер не може да произведе исправан резултат и потребна му је помоћ.

\indent Када се IEEE изузетак деси требало би обевестити и корисника, ово би требало бити синхроно; након заустављања корисник би желио да види све предходно извршене инструкције и све FP регистре који су у preinstruction стању и желе да се увере да ни једна следећа инструкција нема никакав ефекат.

\indent У \textit{MIPS} архитектури, хардверска заустављања су била овако одрађена. Ово заправо ограничава могућности проточне обраде FP операција, јер се не може извршити сљедећа инструкције све док хардвер може бити сигуран да операција FP неће произвести заустављање. Зарад избегавања додавања времена за извршавање, FP операције морају да одлуче да ли ће доћи до заустављања у првој фази. 




\section{FPXX конвеција}

% ------------------------------------------------------------------------------
\chapter{Valgrind}
\label{chp:valgrind}

\indent \textit{Valgrind} је платформа за прављење алата за динамичку бинарну анализу кода. Динамичка анализа обухвата анализу корисничког програма у извршавању, док бинаран анализа обухвата анализу на нивоу машинског кода, снимљеног или као објектни код (неповезан) или као извршни код (повезан). Постоје \textit{Valgrind} алати који могу аутоматски да детектују проблеме са меморијом, процесима као и да изврше оптимизацију самог кода. \textit{Valgrind} се може користити и као алат за прављење нових алата. \textit{Valgrind} дистрибуција тренутно броји следеће алате: детектор меморијских грешака, детектор грешака нити, оптимизатор скривене меморије и скокова, генератор графа скривене меморије и предикције скока и оптимизатор коришћења динамичке меморије. \textit{Valgrind} ради на следећим архитектурама: 
\begin{flushleft}
\textbf{\textit{X86/Linux, AMD64/Linux, ARM/Linux, ARM64/Linux, PPC32/Linux, PPC64/Linux, PPC64LE/Linux, S390X/Linux, MIPS32/Linux, MIPS64/Linux, X86/Solaris, AMD64/Solaris, ARM/Android (2.3.x и новије), ARM64/Android, X86/Android (4.0 и новије), MIPS32/Android, X86/Darwin and AMD64/Darwin (Mac OS X 10.12)}}.
\end{flushleft}

\indent У наредним поглављима биће детаљно описана структура \textit{Valgrind} и његових алата, као и начин употребе са примерима проблема са којима се програмери свакодневно сусрећу.

\section{O Valgrindu}

\indent Алат за динамичку анализу кода се креира као додатак, писан у C програмског језику, на језгро \textit{Valgrind}. 


\begin{center}
\textit{Језгро Valgrinda + алат који се додаје = Алат Valgrinda} 
\end{center}


\indent Језгро \textit{Valgrind}-а омогућава извршавање клијетског програма, као и снимање извештаја који су настали приликом анализе самог програма. 

\indent Алати \textit{Valgrind}-а користе методу бојења вредности. Они заправо сваки регистар и меморијску вредност "боје" (замењују) са вредношћу која говори нешто додатно о оригиналној вредности. 

\indent Сви \textit{Valgrind} алати раде на истој основи, иако информације које се емитују варирају. Информације које се емитују могу се искористити за отклањање грешака, оптимизацију кода или било коју другу сврху за коју је алат дизајниран.

\indent Сваки \textit{Valgrind}-ов алат је статички повезана извршна датотека која садржи код алата и код језгра. Извршна датаоке valgrind представља програм омотач који је на основу --tool опције бира алат који треба покренути и покреће га помоћу системског позива \textbf{\textit{execve}}. Извршна датотека алата статички је линкована тако да се учитава почев од неке адресе која је обично доста изнад адресног простора који користе класичан кориснички програм (на \textbf{\textit{x86/Linux}} и \textbf{\textit{MIPS/Linux}} користи се адреса 0x38000000). У ретким случајевима, када та адреса није потреба, \textit{Valgrind} се може прекомпајлирати да користи неку другу адресу. \textit{Valgrind}-ово језгро прво иницијализује под-систем као што су менаџер адресног простора, и његов унутрашњи алокатр меморије и затим учитава клијентову извршну датотеку. Потом се иницијализују \textit{Valgrind}-ови субсистеми као што су транслациона табела, апарат за обраду сигнала, распоређивач нити и учитавају се информације за дебаговање клијента, уколико постоје. Од тог тренутка \textit{Valgrind} има потпуну контролу и почиње са превођењем и извршавањем клијентског програма. Може се рећи да \textit{Valgrind} врши JIT (\textit{Just In Time}) превођење машинског кода програма у машинкси код програма допуњен инструментацијом. Ниједан део кода клијента се не извршава у свом изворном облику. Алат се умеће у оригинални код на почетку, затим се нови код преводи, сваки основни блок појединачно, који се касније извршава. Процес превођења се састоји из рашчлањивања оригиналног машинског кода у IR (скр. \textit{intermediate representation}) који се касније инструментализује са алтом и поново преводи у нови машински код. 

\indent Резултат свега овога се назива транслација, која се чува у меморији и која се извршава по потреби. Језгро троши највише времан на сам процес прављења, проналажења и извршавања транслације. Оригинални код се никада се извршава. Једини проблем који се овде може догодити је ако се врши транслација кода који се мења током извршавања програма.

\indent IR има неке \textit{RISC} одлике као што су \textit{load/store}, свака операција ради само једну ствар, кад се линеаризује све операције раде само на привременим промељивама и литералима. Да би се подржале све целобројне, FP и SIMD операције над различитим величинама потребно је више од 200 примитвних аритметичко-логичких инструкција. 

\indent Постоје многе компликације које настају приликом смештања два програма у један процс (клијентски програм и програм алата). Многи ресурси се деле између ова два програма, као што су регистри или меморија. Такође, алат \textit{Valgrind}-а не сме да се одрекне тоталне контроле над извршавањем клијетског програма приликом извршавања системских позива, сигнала и нити.

\subsection{Основни блок}

\indent \textit{Valgrind} дели оригинални код у секвенце које се називају основни блокови. Основни блок је праволинијска секвенца машинског кода, на чији се почетак скаче, а која се завршава са скоком, позивом функције или повратком. Сваки код програма који се анализира поново се преводи на захтев, појединачно по основним блоковима, непосредно пре самог извршавања самог блока. Ако узмемо да су основни блокови клијетског кода \textit{BB1, BB2, ...} онда преведене основне блокове обележавамо са \textit{t(BB1), t(BB2), ...} Величина основног блока је ограничена на максимално 60 машинских инструкција. На процесорима \textit{MIPS}, инструкције скока и гранања имају такозвано "одложено извршавање". То значи да се приликом извршавања тих инструкција извршава и инструкција која се налази непосредно иза инструкције гранања или скока. У случају да је последња шесдесета инструкција основног блока инструкција гранања, \textit{Valgrind} учитава и инструкцију која се налази непосредно иза ње, односно шесдесет и прва инструкција. Тиме се омогућава конзистентно извршавање програма који се анализира, као и у случају да се програм извршава без посредства \textit{Valgrind}-а. Уколико након извршених 60 инструкција \textit{Valgrind} није наишао на инструкцију гранања, секвенца инструкција се дели на два или више основних блокова, који се извршавају један за другим.



\subsection{Системски позиви}

\indent Апликациони програми комуницирају са оперативним системом помоћу системских позива (eнг. \textbf{system calls}), тј. преко операција (функција) које дефинише оперативни систем.
\indent Системски позиви се реализују помоћу система прекида: кориснички програм поставља параметре системског позива на одређене меморијске локације или регистре процесора, иницира прекид, оперативни систем преузима контролу, узима парамтре, извршава тражене радње, резултат ставља на одређене меморијске локациј еили у регистре и враћа контролу корисчком програму. 
\indent Апликација која жели да користи неке од ресурса, као што су меморија, процесор или улазно/излазни уређаји, комуницира са језгром опративног система користећи системске позиве. Језгро оператвиног система дели виртуелну маморију на корисничку меморију и системску меморију. Системска меморија је одређена за само језгро оператвиног система, његова проширања, као и за урављачке програме. Кориснички прогстор је део меморије где се налазе све корсничке апликације приликом њиховог изврђавања. Корисничке апликације могу да приступе улазно/излазним уређајима, виртуелној меморији, датотекама ид ругим реуссрисам језгра оператвино система користећи само системске позиве. Системски позиви обезбеђују спрегу између програма који се извршава и оператвиног система. Генерално, реализују се на асемблерском језику, али новији виши програсмки језици, попут језика C и C++, такође омогућавају реализацију системског позива. Пграом кои се извршава може проседити параметре опративном систему на три начина:
\begin{itemize}
  \item прослеђивање параметара у регистрима процесора;
  \item постављањем параметара у меморијској табели, при чему се адреса табеле прослеђује у регистру процесора;
  \item постављањем параметара на врх стека (енг. \textit{push}), које оператвни систем "скида" (енг. \textit{pop}).
\end{itemize}
\indent Системски позиви се извршавају без посредства \textit{Valgrind}-а, зато што језгро \textit{Valgrind}-а не може да прати њихово извршавање у самом језгру оперативног система.


\subsection{Транслација}

\indent У наставку су описани кораци које \textit{Valgrind} извршава приликом анализе програма. Постоји осам фаза транслације. Све фазе осим инструментацје коју обавља алат \textit{Valgrind}-а, обавља језгро \textit{Valgrind}-а.

\begin{itemize}
  \item \textbf{ Дисасемблирање } - процес превођења машинског кода у еквивалетни асемблерски код. \textit{Valgrind} врши превођење машинског кода у интерни скуп инструкција која се називају међукод инструкције. Међукод представља редуковани скуп инструкција (скр. енг. \textit{RISC}). Ова фаза је зависна од архитетктуре на којој се извршава.
  \item \textbf{ Оптимизација 1} - Прва фаза оптимизације линеаризује \textit{IR} репрезентацију. Примењују се неке стандардне оптимизације програмских преводилаца као што су уклањање редудантног кода, елиминација подизраза, једноставно одмотавање петљи и сл.
  \item \textbf{ Инструментација} - Блок кода у \textit{IR} репрезентацији се прослеђује алату, који може произвољно да га трансформише. Приликом инструментације алат у задати блок додаје додатне \textit{IR} операције, кјима проверава исправност рада програма.
  \item \textbf{ Оптимизација 2 } - Друга фаза оптимизације је једноставније од прве, укључује множење констати и уклањање мртвог кода.
  \item \textbf{ Градња стабла } - Линеаризована \textit{IR} репрезентација се конвертује натраг у стабло ради лакшег избора инструкција.
  \item \textbf{ Одабир инструкција } - Стабло \textit{IR} репрезентације се конвертује у листу инструкција које користе виртуалне регистре. Ова фаза се такође разликује у зависности од архитеткуре на којој се извршава. 
  \item \textbf{ Алокација регистара} - Виртуални регистри се замењују стварним. По потреби се уводе пребацивања у меморију. Независна је за платформу, користи позив функција које налазе из који се регистара врши читање и у које се врши упис.
  \item \textbf{ Асемблирање } - Изабране инструкције се енкодују на одговарајући начин и смештају у блок мемроји. Ова фаза се такође разликује у зависноти од архитектуре на који се изршава. ~\cite{SeeMIPSRun}
\end{itemize}

\section{Memcheck}

\indent Меморијске грешке често се најтеже детектују, а самим тим и најтеже отклањају. Разлог томе је што се такви проблеми испољавају недетерминистички и није их лако репродуковати. \textit{Memcheck} је алат који детектује меморијске грешке корисничког програма. Како не врши анализу изворног кода већ машинског, \textit{Memcheck} има могућност анализе програма писаног у било ком језику.

\indent За програме писане у језицима C и C++ детектује следеће уобичајне проблеме:
\begin{itemize}
  \item Приступање недопуштеној меморији, на пример преписивање блокова на хипу, преписивање врха стека и приступање меморији која је већ ослобођена.
  \item Коришћење недефинисаних вредности, вредности које нису иницијализоване или које су изведене од других недефинисаних вредности.
  \item Неисправно особађање хип меморије, као што је дупло ослобађање хип блокова или неупареног коришћења фукнција \textit{malloc/new/new[]} и \textit{free/delete/delete[]}.
  \item Преклапање параметара прослеђених функцијама (нпр. преклапање \textbf{\textit{src}} и \textbf{\textit{dst}} показивача код фукнције \textbf{\textit{memcpy}}.
  \item Цурење меморије.
\end{itemize}

\indent Пуштање преведеног програма кроз \textit{Valgrind}, врши се извршавањем следеће линије у терминалу:

\begin{center}
 valgrind -\--tool=memcheck ./main
\end{center}

\indent -\--tool = опција одређује који алат ће \textit{Valgrind} пакет користити. Програм који ради под контролом \textit{Memcheck}-a je обично 20 до 100 пута спорији него када се извршава самостално, због транслације кода. Излаз програм је повећан за излаз који додаје сам алат \textit{Memcheck}, који се исписује на стандардном излазу за грешке.



\subsection{Коришћење неиницијализованих вредности}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika1.png}
\end{center}
\caption{Пример програма main.c}
\label{fig:main}
\end{figure}

\indent На слици \ref{fig:main} је дат пример програма у коме користимо неиницијализовану променљиву. Грешка о коришћењу неиницијализоване вредности се генерише када програм користи променљиве чије вредности ниси иницијализоване, другим речима недефинисане.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika2.png}
\end{center}
\caption{Детектција неиницијализованих вредности}
\label{fig:memcheck}
\end{figure}

\indent Слика \ref{fig:memcheck} приказује излаз \textit{Valgrind}-а који детектује коришћење недефинисаних вредности у програму. Први део, односно пре три линије се штампају приликом покретања било ког алата који је у склопу \textit{Valgrind}-а, у овом случају \textit{Memcheck}. Следећи део нам показује поруке о грешкама које је \textit{Memcheck} пронашао у програму. Последња линија приказује суму свих грешака које је алат пронашао и штампа се по завршетку рада. \\
\indent На овој слици је приказан излаз из \textit{Valgrind}-а када се открије  коришћење недефинисаних вредности. У програму недефинисана променљива може више пута да се копира, \textit{Memcheck} прати све то, бележи податке о томе, али не пријављује грешку. У случају да се недефинисане вредности користе на начин да од те вредности зависи даљи ток програма или ако је потребно приказити вредности недефинисане промељиве, \textit{Memcheck} пријављује грешку. да би могли да видимо главни извор коришћења недефинисаних вредности у програму, додаје се опција \textit{-\--trace-origins=yes}.

\subsection{Коришћење неиницијализоване или неадресиране вредности у сисстемсом позиву}

\indent \textit{Memcheck} прати све параметре системског позива:
 
\begin{itemize}
  \item Проверава све параметре појединачно, без обзира да ли су иницијализовани.
  \item Проверава да ли системски позив треба да чита из меморије која је дефинисана у програму. \textit{Memcheck} проверава да ли је цела меморија адресирана и иницијализована.
  \item Ако системски позив треба да пише у меморију, \textit{Memcheck} проверава да ли је та меморија адресирана.
\end{itemize}

\indent После системског позива \textit{Memcheck} прецизно ажурира иноформације о промени у меморији које су постављене у системског позиву.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika3.png}
\end{center}
\caption{Пример програма main1.c}
\label{fig:main1}
\end{figure}

\indent На слици \ref{fig:main1} дат је пример позива системског позива са неисправним параметрима.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika4.png}
\end{center}
\caption{Пример излаза за програм main1.c}
\label{fig:memcheck1}
\end{figure}

\indent На слици \ref{fig:memcheck1} је извештај који даји добијамо након анализе програма main1.c. Можемо да видимо да је \textit{Memcheck} приказао информације о коришћењу неиницијализованих вредности у системским позивима. Прва грешка приказује да параметар \textit{buf} системског позива \textit{write()} показује на неиницијализовану вредност. Друга грешка приказује да је податак који се прослеђује системског позиву \textit{exit()} недефинисан. Такође, приказане су и линије у самом програму где се ове вредности користе.

\subsection{Недопуштено особађање меморије}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika5.png}
\end{center}
\caption{Пример програма main2.c}
\label{fig:main2}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika6.png}
\end{center}
\caption{Пример излаза за програм main2.c}
\label{fig:memcheck2}
\end{figure}

\indent На слици \ref{fig:main2} дат је пример програма у коме се нелегално ослобађа меморија. \textit{Memcheck} прати свако алоцирање меморије које програм направи употребом функција \textit{malloc/new}, тако да он увек поседује информацију да ли су аргументи који се прослеђују функцијама \textit{free/delete} легитимни или не. У нашем примеру, програм ослобађа исту меморијску зону два пута. Извештај о недопуштеном ослобађању меморије приказан је на слици \ref{fig:memcheck2}.

\indent \textit{Memcheck} је пријавио да је програм покушао два пута да ослободи неку меморијску зону.  Такође, \textit{Memcheck} ће нам пријавити и ако програм покуша да ослободи меморијску зону преко показивача који не показује на почетак динамичке меморије.

\subsection{Детекција цурења меморије}

\indent \textit{Memcheck} бележи податке о свим динамичким блоковима који су алоцирани током извршавања програма позивом функција \textit{malloc(), new()} и др. Када програм прекине са радом, \textit{Memcheck} тачно зна колико меморијских блокова није ослобођено.

\indent Ако је опција \textit{-\--leak-check} адекватно подешена, за сваки неослобођени блок \textit{Memcheck} одређује да ли је могуће приступити том блоку преко показивача.

\indent Постоје два начина да приступимо садржају неког меморијског блока преко показивача. Први начин је преко показивача који показује на почетак меморијског блока. Други начин је преко показивача који показује на садржај унутар меморијског блока.

\indent Постоји неколико начина да сазнамо да ли постоји показивач који показује на унутрашњост неког меморијског блока:
\begin{itemize}
  \item Постојао је показивач који је иницијално показивао на почетак блока, али је намерно (или ненамерно) померен да показује на унутрашњост блока.
  \item Ако постоји нежељена вредност у меморији, која је у потпуности неповезана и случајна.
  \item Ако постоји показивач на низ C++ објеката (који поседују деструкторе) који су алоцирани са \textit{new[]}. У овом случају, неки компајлери чувају "магични показивач" који садржи дужину низа од почетка блока.
\end{itemize}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika7.png}
\end{center}
\caption{Пример показивача на меморијски блок}
\label{fig:memblok}
\end{figure}

\indent На слици \ref{fig:memblok} је приказано 9 могућих случајева када показивачи показују на неке меморијске блокове. Сваки могући случај када показивач показује на неки меморијски блок може се представити са једним од приказаних 9 случајева. \textit{Memcheck} обједињује неке од ових случајева, тако да добијамо наредне четири категорије.

\begin{itemize}
  \item "Још увек доступан". Ово покрива примере 1 и 2 на слици \ref{fig:memblok}. Показивач који показује на почетак блока или више показивача који показују на почетак блока су пронађени. Зато што постоје показивачи који показују на меморијску локацију која није ослобођена, програмер може да ослободи меморијску локацију непосредно пре завршетка извршавања програма.
  \item "Дефининитивно изгубљен". Ово се односи на трећи случај на слици \ref{fig:memblok}. Ово значи да је немогуће пронаћи показивач који показује на меморијску блок. Блок је проглашен изгубљеним, заузета меморија не може да се ослободи пре завршетка програма, јер не постоји показивач на њу.
  \item "Индиретно изгубљен". Ово покрива случајеве 4 и 9 на слици \ref{fig:memblok}. Меморијски блок је изгубљен, не зато што не постоји показивач који показује на њега, него зато што су сви блокови који указују на њега изгубљени. На пример, ако имамо бинарно стабло и корен је изгубљен, сва деца чворови су индиректно изгубљени. С обзиром на то да ће проблем нестати ако се порави показивач на дефинитивно изгубљен блок који је узроковао индиректно губљење блока, \textit{Memcheck} неће пријавити ову грешку уколико није укључена опција \textit{-\--show-reachable=yes}.
  \item "Могуће изгубљен". Ово су случајеви од 5 до 8 на слици \ref{fig:memblok}. Пронађен је један или више више показивача на меморијски блок,  али најмање један од њих показује на унутрашњост меморијског блока. То може бити само случајна вредност у меморији која показује на унутрашњост блока, али ово не треба сматрати у реду док се не разреши случај показивача који показује на унутрашњост блока.
\end{itemize}

\indent Ако постоји забрана приказивања грешке за одређени меморијски блок, без обзира којој од горе поменутих категорија припада, на неће бити приказана.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika8.png}
\end{center}
\caption{Резиме цурења меморије}
\label{fig:memcurenje}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika9.png}
\end{center}
\caption{Извештај о цурењу меморије}
\label{fig:memizv}
\end{figure}


\indent На слици \ref{fig:memcurenje} је дат резиме цурења меморије који исписује \textit{Memcheck}. Ако је укључена опција \textit{-\--leak-check=yes}, \textit{Memcheck} ће приказати детаљан извештај о сваком дефинитивно или могуће изгубљеном блоку,  као и о томе где је он алоциран. \textit{Memcheck} нам не може рећи када, како или зашто је неки меморијски блок изгубљен. Генерано, програм не треба да има ниједну дефинитвно или могуће изгубљен блок на излазу.

\indent На слици \ref{fig:memizv} је приказан извештај који нам даје \textit{Memcheck} о дефинитивном губитку два блока величине 16 и 19 бајта, као линију у програму где су они алоцирани.

\indent Због постојања више типова цурења меморије поставња се питање које цурење меморије на излазу из програма треба да посматрамо као "грешку", а коју не. \textit{Memcheck} користи следећи критеријум:

\begin{itemize}
  \item \textit{Memcheck} сматра да је цурење меморије "грешка" само ако је укључена опција \textit{-\--leak-check=full}. Другим речима, ако подаци о цурењу меморије нису приказани, сматра се да то цурење није "грешка".
  \item Дефинитивно и могуће изгубљени блокови се сматрају за праву "грешку", док индиректно изгубљени и још увек доспуни блокови се не сматрају као грешка.
\end{itemize}


\section{Cachgrind}

\indent \textit{Cachgrind} је алат који симулира и прати приступ скривеној меморји машине на којој се програм, који се анализира, извршава. Он симулира скривену меморију машине, која има први ниво скривене меморије подељен у две одвојене независне секције: \textit{I1} - секција брзе меморије у кој се смештају инструкције и \textit{D1} - секција брзе меморије у којој се смештају подаци. Други ниво скривене меморије коју \textit{Cachgrind} симулира је обједињен - \textit{L2}. Овај начин конфигурације одговара многим модерним машинама.

\indent Постоје машине које имају и трећи ниво брзе меморије \textit{I3}. У том случају, \textit{Cachgrind} симулира приступ трећем нивоу. Генерално гледано, \textit{Cachgrind} симулира  \textit{L1}, \textit{D1} и \textit{LL} (последњи ниво скривене меморије).

\indent \textit{Cachgrind} прикупља следеће статистичке податке о програму који анализира (скраћенице које се користе даље у тексту су дате у заградама):

\begin{itemize}
  \item \textit{I} читање брзе меморије ( \textit{Ir}, што представља број извршених инструкција), \textit{I1} број промашаја читања (\textit{I1mr}) и број промашаја читања инструкција нивоа \textit{LL} брзе меморије (\textit{ILmr}).
  \item \textit{D} читање брзе меморије (\textit{Dr}, што је једнако броју читања меморије), \textit{D1} број промашаја читања (\textit{D1mr}, и број промашаја читања података нивао \textit{LL} брзе меморије (\textit{DLmr}).
  \item \textit{D} писања у брзу меморију (\textit{Dw}, што је једнако броју писања у меморију), \textit{D1} број промашаја писања у брзу меморију и број промашаја писања података у нивоу \textit{LL} брзе меморије (\textit{DLmw}).
  \item Број условно извршених грана (\textit{Bc}) и број промашаја условно извршених грана (\textit{Bcm}).
  \item Број индиректно извршених грана (\textit{Bi}) и број промашаја индиректно извршених грана (\textit{Bim}).
\end{itemize}

\indent Приметимо да је број приступа \textit{D1} делу брзе меморије једнак збиру \textit{D1mr} и \textit{D1mw}, док је укупан број приступа нивоу \textit{LL} једнак збиру  \textit{ILmr}, \textit{DLmr} и \textit{DLmw} број приступа. Ова статистика се прикупља на нивоу целог програма, као и за појединачно на нивоу функција. Може се такође, добити и број приступа скривеној меморији за сваку линију кода у оригиналном програму. На модерним машинама \textit{L1} промашај кошта око 10 процесорских циклуса, \textit{LL} промашај кошта око 200 процесорских циклуса, а промашаји условно и инидиректно извршене гране од 10 до 30 процесорских циклуса.

\subsection{Коришћење Cachgrind-a}

\indent На почетку коришћења алата \textit{Cachgrind}, програм који желимо да анализирамо покрећемо самим \textit{Cachgrind}-ом. На тај начин прикупљамо информације које су нам потребне за касније профилисање кода. Затим покрећемо алат \textit{cg\_annotate} у оквиру пакета \textit{Valgrind} који нам приказује детаљан извештај о програму који анализирамо са \textit{Cachgrind}-ом. Опционо, можемо да користимо алат \textit{cg\_merge} да сумирамо у једну датотеку више излаза које смо добили вишеструким покретањем \textit{Cachgrind}-а над истим програмом. Ту датотетку касније користимо као улаз у \textit{cg\_annotate}. Такође, можемо да користимо алат \textit{cg\_diff} који прави разлику између више излаза из алата \textit{Cachgrind}, које касније користимо као улаз у алат \textit{cg\_annotate}

\indent Покретање самог алата \textit{Cachgrind} врши се извршавањем следеће линије у терминалу:

\begin{center}
 valgrind -\--tool=cachgrind ./main
\end{center}


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika10.png}
\end{center}
\caption{Извештај алата \textit{Cachgrind}}
\label{fig:cachgrind}
\end{figure}

\indent Извршава програма кроз \textit{Cachgrind} траје веома споро. Након завршетка рада, добијају се статитстике као што је приказано на слици \ref{fig:cachgrind}.

\subsection{\textit{Cachgrind} метаподаци}

\indent У наставку су описани метаподаци који се чувају у структурама.

\indent \textbf{Глобално стање брзе меморије}. Прва структура која се налази у склопу \textit{Cachgrind} метаподатака је глобано стање брзе меморије. Она представља три дела симулиране брзе меморије (\textit{L1}, \textit{D1},  \textit{LL}). Њене вредности се освежавају приликом извршене сваке инструкције програма чија се брза меморија симулира, тачније, приликом позива функције које симулирају приступ брзој меморији циљне платформе. Функцијама се прослеђују информациј ео приступу брзој меморији, као што су адресе и величина меморије којој се приступа.

\indent Симулација приступа брзој меморији има следеће карактеристике:

\begin{itemize}
  \item Када се деси помашај уписа у брзу меморију, блок који је потребно уписати се семпта у \textit{D1} део брзе меморије. 
  \item Инструкције које содификују врдност меморије третирају се као читање брзе меморије. Наиме, инструкције које мењају садржај брзе меморије најпре читају садржај брзе меморије, модификују вредност и снимају нову вредност. Самим тим, упис у брзу меморију не може да изсазове промашај, јер је гарантован успешним читањем. Такође, циљ \textit{Cachgrind}-а није да прикаже колико пута се приступа брзој меморији, већ да прикаже број промашаја приступа брзој меморији.
   \item Линија у брзој меморији, којој одговара садржај у меморији са директним приступом, одређује се као \textit{ (M + N - 1) }, где је величина линије = 2\^M бајта, (величина брзе меморије / величина линија) = 2\^N бајта.
   \item \textit{L2} део брзе меморије реплицира све уносе у \textit{L1} део брзе меморије.
   \item Онај блок у брзој меморији који се најмање користи ће бити избачен из брзе меморије уколико је потребно убацити нови блок података у брзу меморију.
   \item Са референцама које показују на две линије у кеш меморији рукује се на следећи начин:
   	\begin{itemize}
   		\item уколико су пронађена оба блока у брзој меморији, рачунамо сам оједан погодат;
   		\item уколико један блок нађемо у брзој меморији, а други не, рачунамо један промашај (и нула погодатака);
   		\item уколико оба блока не пронађемо у брзој меморији, рачунамо један промашај (не два).
   	\end{itemize}
\end{itemize}

\indent Параметри симулиране брзе меморије (величина брзе меморије, величина линије и асоцијативност) одрешују се на један од два начина. Први наин је потребом \textit{cpuid} наредбе. Други начин представља ручно унопење параметара симулиране брзе меморије, прикиком покретања самог \textit{Cachgrind}.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika11.png}
\end{center}
\caption{Структура централне табеле трошкова}
\label{fig:tabelaTroskova}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika12.png}
\end{center}
\caption{Структура табеле информација о инструкцијама}
\label{fig:infoInstr}
\end{figure}

\indent \textbf{Централна табела трошкова}. Друга структура која чини метаподатке алата \textit{Cachgrind} је централна табнела трошкова. Свака линија укоду која се инструментализује, алоцира једну овакву табелу у коју смешта податке о приступу брзој меморији, броју погодака и промашаја приступа брзој меморији, који се дешавају приликом извршавања саме линије кода. На слици \ref{fig:tabelaTroskova} приказане су структуре које представљају ценстралну табелу трошкова. \textit{ULong} је 64-битна целобројна вредност. Узимамо 64-битну вредност, јер број приступа може да буде већи него што може да се представи 32-битном целобројном вредношћу. У \textit{CC} структури \textit{m1} и \textit{m2} представљају број промашаја за \textit{L1} и \textit{LL} део скривене меморије. Структура \textit{lineCC} садржи три \textit{CC} елемента: за читање \textit{I} дела, за читање дела \textit{D} и за писање у део \textit{D} скривене меморије. Поље \textit{next} је потребно јер је централна табела трошкова представљена као променљива \textit{"heš"} табела. Поље \textit{line} представља број линије у коду која одговоара тој табели трошкова. Сам број линије није довољан да би се пронашла линија у коду којој одговара централна табела трошкова (име фајла је потребно). У пракси, то значи централна табела трошкова има три новоа: трошкови су груписани по имену фајла, затим по имену функције и на крају по броју линије.


\indent \textbf{Табела информација о инструкцијама}. Трећа структура која чини метаподатке алата \textit{Cachgrind} је табела информација о инструкцијама. Она се користи за чување непроменљивих информација о самим инструкцијама током самог процеса инструментације. На овај начин се смањује величина додатог кода којим се анализира код. Повећава се брзина извршавања самог алата, јер се самњује број аргумената који се просеђују функцијама, које врше симулацију приступа број меморији.


\indent Свакој инструментализованој инструкцији додељује се по једно поље у табели информација о инструкцијама, које садржи структуру \textit{instr \_info},  приказаној на слици \ref{fig:infoInstr}. Поље \textit{instr\_addr} представља адресу инструкције \textit{instr\_size} представља величину инструкције изражену у бајтовима, \textit{data\_size} чува величину података коме инструкција приступа (0 уколико инструкција не приступа меморији) и \textit{parent} показује на поље у табели трошкова за исту линију кода одакле је инструкција изведена.

\subsection{Инструментација}

\indent Први корак приликом инструментације кода односи се на пролаз кроз све основне блокове појединачно ради пребројавања инструкција које се налазе у њима. На основу овог броја се креира листа \textit{instr \_info} елемената, при чему сваки елемент листе одговара једној инструкцији у основном блоку.

\indent У другом пролазу, \textit{Cachgrind} врши категоризацију оригиналних инструкција, \textit{Cachgrind} дели инструкције у следеће категорије:

\begin{itemize}
  \item Инструкције које не приступају меморији, нпр. \textit{move \$t3, \$a0}
  \item Инструкције које читају садржај меморије, нпр. \textit{lw \$t3, 4(\$a0}
  \item Инструкције које уписују садржај регистара у меморију, нпр. \textit{sw \$t3, 4(\$a0)}
  \item Инструкције које модификују садржај меморијске локације
  \item Инструкције које читају садржај из једне меморијске локације и тај садржај уписују у другу меморијску локацију.
\end{itemize}

\indent Свака инструкција система базираног на \textit{MIPS} процесорима је растављена на више \textit{UCode} инструкција, тако да \textit{Cachgrind} одређује којој категорији оригинална инструкција припада на основу \textit{LOAD} и \textit{STORE} \textit{UCode} инструкција. \textit{Cachgrind} чита инфромације које помажу при отклаљању грешака. На основу ових информација он креира елементе \textit{lineCC} у централној табели трошкова. Затим иницијализује одређене \textit{instr \_info} елементе у  низ који је иницијализован за сваки основни лбок појединачно (где је н-ти елемент \textit{instr \_info} одговара н-тој инструкцији у основном блоку). Када је иницијализовао све елементе \textit{lineCC} и \textit{instr \_info} алат \textit{Cachgrind} извршава процес инструментализације кода који се састоји из позива одговарајућих \textit{C} функција, које симулирају приступ брзој меморији циљне платформе. Која \textit{C} функција ће бити позвана зависи од категорије којој инструкција припада. Постоје само четири врста \textit{C} функција које симулирају приступ брзој меморији, јер функције које припадају другој и четврој категорији позивају исту \textit{C} функцију за симулирање приступа брзој меморији. Број параметара који се прослеђује \textit{C} функција се, одређује на основу категорије којој та функција припада.

\subsection{Приказ статистичких информација}

\indent Приликом завршетка анализе програма \textit{Cachgrind} похрањује прикупљену табелу тропкова у датотеку која се назива \textit{cachgrind.out.pid}; при чему \textit{pid} представља јединстевени идентификатор процеса који се извршио. Алат групише све трошкове по фајловима и функцијама којима ти трошкови припадају. Глобална статистика се рачуна накнадно, приликом приказа резултата. На овај начин се штеди јако пуно времана приликом анализе кода. Функције које симулирају приступ брзој меморији се позивају јако често, тако да би додавање још неколико инструкција које сабирају , знатно успорило и овако споро извршавање алата.

\section{Helgrind}

\indent \textit{Helgrind} је алат у склопу програмског пакета \textit{Valgrind} који открива грешке синхронизације приликом употребе модела нити \textit{POSIX}.

\indent Главне апстракције модела нити \textit{POSIX} су: група нити која дели заједнички адресни простор, формирање нити, чекање за завршетак извршавања функције нити, излаз из функције нити, мутекс објекти, условне промељиве, читај-пиши закључавање и семафори. \textit{Helgrind} може да открије следеће три класе грешака:

\begin{itemize}
  \item Лоша употреба интерфејса за програмирање нити \textit{POSIX}.
  \item Потенцијално блокирање нити које проистиче из лошег редоследа закључавања и откључавања променљивих.
  \item Приступ меморији без адекватног закључавања или синхронизације.
\end{itemize}

\indent Проблеми као што су ови често узрокују нерепродуктивне, временски зависне падове програма и веома их је тешко открити. Алат \textit{Helgrind} поседује механизам за веома прецизно праћење свих апстракција које користе модел нити \textit{POSIX}. \textit{Helgrind} даје најбоље резултате ако програм који се анализира користи само интерфејс за програмирање нити \textit{POSIX}.

\subsection{Лоша употреба интерфејса за програмирање нити \textit{POSIX}}

\indent \textit{Helgrind} пресреће позиве ка функцијама библиотеке \textit{pthread}, и због тога је у могућности да открије велики број грешака. Овакве грешке могу да доведу до недефинисаног понашања програма и до појаве грешака у програмима које је касније веома тешко открити. Грешке које \textit{Helgrind} проналази су: откључавање неважећег мутекса, откључавање мутекса који није закључан, откључавање мутекса кога је закључала друга нит, уништавање неважећег или закључаног мутекса, рекурзивно закључавање нерекурзивног мутекса, деалокација меморије која садржи закључан мутекс, прослеђивање мутекса као аргумента функције која очекује као аргумент  \textit{reader-writer lock} и обрнуто, када \textit{pthread} функција врати код грешке који је потрено додатно обрадити, када се нит уништи, а да још држи закључану промељиву, прослеђивање функцији \textit{pthread\_cond\_wait} незакључан мутекс, незважећи мутекс или мутекс кога је закључала друга нит, неконзистентне везе између условних промељивих и њихових одговарајућих мутекса, неважећа или дупла иницијализација \textit{pthread barrier}, уништавање \textit{pthread barrier} који никада није иницијализован или кога нити чекају, чекање на \textit{pthread barrier} објекта који није никада иницијализован, за све \textit{pthread} функције које \textit{Helgrind} пресреће, генерише се податак о грешци ако функција врати код грешке, иако \textit{Helgrind} није нашао грешке у коду.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika13.png}
\end{center}
\caption{Пример приказа грешке у програму}
\label{fig:helgrind}
\end{figure}

\indent Провере које се односе на мутексе се такође примењују и на \textit{reader-writer lock}. Пријављена грешка приказује и примарно стање стека које показје где је детектована грешка. Такође, уколико је могуће исписује се и број линије у самом коду где се грешка налази. Уколико се грешка односи на мутекс, \textit{Helgrind} ће приказати и где је први пут детектовао проблематични мутекс \ref{fig:helgrind}. 

\subsection{Потенцијално блокирање нити}

\indent \textit{Helgrind} прати редослед којим нити закључава промељиве. На овај начин \textit{Helgrind} детектује потенцијалне делове кода који могу довести до блокорања нити. На овај начин је могуће детектовати грешке које се нису јавиле током самог процеса тестирања програма, већ се јављају касније током коришћења истог.

\indent Илустрација овактвог проблема је дата у наставку.

\begin{itemize}
  \item Претпоставимо да је дељени објекат О коме да би приступили морамо да закључамо две променљиве М1 и М2.
  \item  Замислимо затим да две нити Т1 и Т2 желе да приступе дељеној променљивој О. До блокорања нити долази када нит Т1 закључа М1, а у истом тренутку Т2 закључа М2. Након тога нит Т1 остане блокирана јер чека да се откључа М2, а нит Т2 остане блокирана јер чека да се откључа Т2.
\end{itemize}


\indent \textit{Helgrind} креира граф који представља све променљиве које се могу закључати, а које је открио у прошлости. Када нит наиђе на нову променљиву коју закључава, граф се освежи и проверава се да ли граф садржи круг у коме се налазе закључане променљиве. Постојање круга у коме се налазе закључане променљиве је знак да је могуће да ће се нити некада у току извршавања блокирати. Ако постоје више од две закључане променљиве у кругу проблем је још озбиљнији.


\subsection{Приступ меморији без адекватног закључавања или синхронизације}

\indent Приступ подацима без адекватног закључавања или синхронизације се односи на проблем када две или више нити приступају дељеном податку без синхронизације. На овај начин је могуће да две или више нити у истом тренутку приступе дељеном објекту. 

\subsection{Принцип приступа промљивој без адекватне синхорнизације}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika14.png}
\end{center}
\caption{Пример приступа променљивој без адекватне синхронизације}
\label{fig:main4}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika15.png}
\end{center}
\caption{Извештај \textit{Helgrind}-а за приступ промељивој без синхронизације }
\label{fig:izvestaj}
\end{figure}

\indent На слици \ref{fig:main4} приказан је пример програма променљивој без адекватне синхронизације.

\indent Проблем је у томе што ништа не спречава нити родитељи дете да у исто време приступе и промене вредности дељене променљивој \textit{var}. Приликом анализе оваквог програма алатом \textit{Helgrind} добија се извештај који је приказан на слици \ref{fig:izvestaj}.

\indent У извештају који је приказан на слици \ref{fig:izvestaj} можемо тачно да видиммо које нити приступају променљивој без синхронизације, где се врши сам приступ променљивој, име и величину саме променљиве којој нити приступају ради промене њене вредности.


\subsection{Алгоритам детекције приступа променљивој без синхронизације}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika16.png}
\end{center}
\caption{"Десило се пре" принцип}
\label{fig:dspPrincip}
\end{figure}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika17.png}
\end{center}
\caption{Пример излаза из \textit{Helgrind}-а}
\label{fig:helgrind}
\end{figure}


\indent Алгоритам за детекцију приступа промељивој без синхронизације односи се на "десило се пре" приступ. У наставку је дат пример који објашњава "десило се пре" принцип \ref{fig:dspPrincip}.

\indent Нит родитељ креира нит дете. Затим обе мењају вредност промељиве \textit{var}, а затим нит родитеља чека да нит детета изврши своју функцију. Овај програм није добро написан јер не можемо са сигурношћу да знамо која је вредност промљиве \textit{var} приликом штамања исте. Ако је нит родитеља бржа од нити дете, онда ће бити штампана вредност 10, у супротном ће бити 20. Брзина извршавања нити родитељ и дете је нешто на шта програмер нема утицаја. Решење овог проблема је у закључавању промељиве \textit{var}. На пример, можемо да пошаљемо поруку из нити родитељ након што она промени вредност промељиве \textit{var}, а нит дете неће променити вредност променљиве \textit{var} док не добије поруку. На овај начин смо сигурни  да ће програм исписати вредност 10. Размена порука креира "десило се пре" зависност између две доделе вредност: \textit{var = 20;} се догађа пре \textit{var = 10;}. Такође, сада више немамо приступ променљивој без синхронизације. Није обавезно да шаљемо поруку из нити родитељ. Можемо послати поруку из нити дете након што она изврши своју доделу. На овај начин смо сигурни да ће се исписати вредност 20.

\indent Алат \textit{Helgrind} ради на истом овом принципу. Он прати сваки приступ меморијској локацији. Ако се локација, у овом примеру \textit{var}, приступа из две нити, \textit{Helgrind} проверава да ли су ти приступи повезани са "десило се пре" везом. Ако нису, алат пријављује грешку о приступу променљивој без синхронизације.

\indent Ако је приступ дељеној променљивој из две или више програмерске нити повезан са "десило се пре" везом, значи да постоји синхорнизациони ланац између програмских нити које обезбеђује да се сам приступ одвија по тачно одређеном редоследу, без обзира на стварне стопе напредка појединачних нити.

\indent Стандардне примитиве нити креирају "десило се пре" везу:
\begin{itemize}
  \item Ако је мутекс откучан од стране нити Т1, а касније или одмах закључан од стране нити Т2, онда се приступ меморији у функцији Т1 дешава пре него што нит Т2 откључа мутекс да би приступила меморији
  \item Иста идеја се односи и на \textit{reader-writer} закључавање променљивих
  \item Ако је кондициона промељива сигнализирана у фукнцији нити Т1 и ак одруга нит Т2 чека на тај сигнал, да би наставила са радом, онда се меморијски приступ у Т1 дешава пре сигнализације, док нит Т2 врши приступ меморији након што изађе из стања чекања на сигнал који шаље нит Т1.
  \item Ако нит Т2 наставља са извршавањем након што нит Т1 ослободи семафор, онда кажемо да постоји "десило се пре" релација између програмских нити Т1 и Т2.
\end{itemize}

\indent \textit{Helgrind} пресреће све горе наведене догађаје и креира граф који представља све "десило се пре" релације у програму. Такође, он прати све приступе меморији у програму. Ако постоји приступ некој меморијској локацији у програму од стране две нити и \textit{Helgrind} не може да нађе путању кроз граф од једног приступа до другог, генерише податак о грешци у програму који анализира.

\indent \textit{Helgrind} не проверава да ли постоји приступ меморијској локацији без синхорнизације уколико се сви приступи тој локацији односе на читање садржаја те локације. Два приступа су у "десило се пре" релацији, иако постији призвољно дугачак ланац синхронизације догађаја између та два приступа. Ако нит Т1 приступа локацији М, затим сигнализира нит Т2, која касније сигнализира нит Т3 која приступа локацији М, кажемо да су ова два приступа између нити Т1 и Т3 у "десило се пре" релацији. иако између њих не постоји директна веза.

\indent \textit{Helgrind} алгоритам за детекцију приступа меморији без синхорнизације прикупљене информације приказује у форми приказаној на слици \ref{fig:helgrind}. 

\indent На слици \ref{fig:helgrind} можемо да приметимо да \textit{Helgrind} најпре исписује податке где су нити које узрокују грешку направљене. Главни података о грешци почиње са \textit{"Possibal data race during read"}. Затим се исписује адреса где се насихорни приступ меморији дешава, као и величина меморије којој се приступа. У наставку \textit{Helgrind} исписује где друга нит приступа истој локацији. На крају, \textit{Helgrind} покренут са опцијом \textit{-\--read-var-inof=yes} исписује и само име променљиве којој се приступа, као и где у програму је та променљива декларисана.



\section{Callgrind}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika18.png}
\end{center}
\caption{Пример визуелизације функција}
\label{fig:callgrind}
\end{figure}

\indent \textit{Callgrind} је алат који генерише листу позива функција користичког програма у виду графа. У основним подашавањима сакупљени подаци састоје се од броја извршених инструкција, њихов однос са линијом у извршном коду, однос позиваоц/позван између функција, као и број таквих позива. Додатна подешавања омогућавају анализирање кода током изршавања. 

\indent Подаци који се анализирају се записују у фајл након завршетка рада програма и алата. Подржане команде су:

\begin{description}
	\item[\textit{callgrind\_annotate}] - на основу генерисаног фајла приказује листу функција. Пример визуелизације листе функција приказан је на слици \ref{fig:callgrind}. За графичку визуелизацију препоручују се додатни алати (\textit{KCashegrind}), који олакшава навигацију уколико \textit{Callgrind} направи велику количину података.
	\item[\textit{callgrind\_control}] - ова команда омогућава интераквину контролу и надгледање програма приликом извршавања. Могу се добити информације о стању на стеку, може се такође у сваком тренутку генерисати профил. 
\end{description}


\indent Алат \textit{Cachgrind} сакупља податке, односно броји догађаје који се дешавају директно у једној функцији. Овај механизам сакупљања података се назива ексклузивним.

\indent Алат \textit{Callgrind} проширује ову фукнционалност тако што пропагира цену функције до њених граница. На пример, ако фукнција \textit{foo} позива фукнцију \textit{bar}, цена функције \textit{bar} се додаје фукнцији \textit{foo}. Када се овај механизам примени на целу функцију, добија се слика такозваних инклузивних позива, где цена сваке функције укључује и цене свих фукнција које она позива, директно или индиректно.

\indent Захваљујући графу позива, може да се одреди, почевши од \textit{main} функције, која фукнција има највећу цену позива. Позиваоц/позван цена је изузетно корисна за профилисање фукнција која имају више позива из разних функција, и где имамо прилику за оптимизацију нашег програма мењајући код у функцији која је позиваоц, тачније редуковањем броја позива.

\indent Могућност детектовања свих позива функција, као и завистно инструкција алата  \textit{Callgrind} зависи од платформе на којој се извршава. Овај алат најбоље ради на \textit{x86} и \textit{amd64}, али нажалост не даје најтачније резултате на следећим платформама \textit{PowerPc}, \textit{ARM} и \textit{MIPS}. Разлог томе је што код наведених платформи не постоји експлицитан позив или инструкција у скупу инструкција, па  \textit{Callgrind} мора да се ослања на хеуристике да би детектовао позиве или инструкције.


\section{Massif}

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.75]{slika19.png}
\end{center}
\caption{Приказ оптерећења хипа коришћењем \textit{Massif} алата}
\label{fig:massif}
\end{figure}

\indent \textit{Massif} је алат који хип меморије корисничког програма. Обухвата, како меморију којој корисник може да приступи, тако и меморију која се користи за помоћне концепте као што су \textit{book-keeping} бајтова и простор за поравнање. Може да израчуна величину стек меморије програма, али ова опција није подразумевана, већ мора експлицитно да се наведе.

\indent Анализа програмског хипа, на модерним рачунарима који користе виртуалну меморију, доноси предност у виду убрзавања програма, јер мањи програми имају бољу искоришћеност кеша и избегавају страничење. Код програма који захтевају велику количину меморије, добра искоришћеност хипа смањује шансу за изгладљивање простора за размену (енг. \textit{swap space}) корисничке машине.

\indent Постоје одређена цурења меморије која не спадају у класичне проблеме цурења меморије, такве пропусте не могу детектовати алати као што је \textit{Memcheck}. Ово се дешава зато што меморија није заправо изгубљена, показивач на њу и даље постоји, али она се више не користи. Програми који имају овакав тип цурења меморије до непотребне количине које користе током свог извршавања. \textit{Massif} помаже у откриваљу баш оваквих цурења меморије. 

\indent \textit{Massif} не даје само информацију о томе колико хип меморије се користи, већ и детаљне информације које упућују на то који део програма је одговоран за алоцирање те меморије.

\subsection{Коришћење \textit{Massif}-а}


\indent Програм који се извршава под алатом \textit{Massif} се ради веома споро. Након завршетка рада, све статистике су исписане у фајл. Подразумевани фајл у којо се пише је \textit{massif.out.<pid>}, где \textit{<pid>} представља ID процеса. Може се променити фајл у коме ће се исписивати командом \textit{-\--massif-out-file}.

\indent Да би информације које је \textit{Massif} сакупио могли да видимо у читљивом формату, користимо \textit{ms\_print}. Ако имамо фајл \textit{massif.out.1234}: 


\begin{center}
 ms\_print massif.out.1234
\end{center}

\indent \textit{ms\_print} прозводи граф који показује на трошење меморије током извршавања програма, као и детаљне информације о различитим тачкама програма које су одговорне о алокацији меморији. Коришћење различитих скрипти за презентацију резултата је намерно, јер одваја сакупљање података од презентације, као и да је могуће додати нов начин приказа података у сваком тренутку.

\indent На слици \ref{fig:massif} приказан је пример излаза из алата \textit{Massif}. Величина графа може бити промењена коришћењем \textit{ms\_print} опција \textit{-\--x} и \textit{-\--y}. Свака вертикала представља пресек стања искоришћености меморије у одређеном тренутку времена. Текст на дну слике \ref{fig:massif} показује да смо имали 25 пресека. \textit{Massif} почиње тако што одради пресек за сваку алокацију и деалокацију хипа, али ако се програм извршава дуже \textit{Massif} све ређе врши пресеке. У случају сложених програма, који се извршавају дуже \textit{Massif} не чува почетне пресеке када достигне максималну вредност пресеке. Подразумевана количина пресека коју алат \textit{Massif} чува је 100, ово се може променити коришћењем опције \textit{-\--max-snapshots}. Ово значи да је одговарајући број пресека стања сачуван у сваком тренутку рада програма.

\indent Одређени пресеци су детаљније обрађени. Обрађени пресеци су представљени у графу знаком '@'. На дну слике \ref{fig:massif} је наглашено да постоје три стања која су детаљније обрађена (стање 9, 14 и 24). Подразумевано је да се свако десето стање обрађује детаљније, али и ово се може променити опцијом \textit{-\--detailed-freq}.

\indent Детањније обрађени пресеци могу бити представљени и знаком '\#', али у том случају значи да је искоришћеност меморије у том тренутку била највећа. Овакав пресека мора да се појави барем једном у графу. На слици \ref{fig:massif} се види да је такав пресек, пресек број 14.

\indent Утврђивање који од пресека је пресек са најискоришћенијом меморијом није увек тачан. Разлог томе је да \textit{Massif} узима у обзир само пресеке код којих се десила деалокација, овим се избегава обрађивање многих непотребних пресека, али значи да ако програм никада не деалоцира меморију, неће бити обрађених пресека са најискоришћенијом меморијом. Још један разлог јесте да обрађивање пресека са најискоришћенијом меморјим одузима доста времана. Због тога \textit{Massif} чува само она стања чија је величина износи 1\% од величине пресека где је искоришћеност меморије била највећа. 

\subsection{Мерење све меморије}


\indent Треба нагласити да алат \textit{Massif} мери само хип меморију, односно меморију која је алоцирана \textit{malloc}, \textit{calloc}, \textit{realloc}, \textit{memalign}, \textit{new}, \textit{new[]} и пар других сличних функција. Ово значи да \textit{Massif} не мери меморију која је алоцирана системским позивима као што су \textit{mmap}, \textit{mremap} и \textit{brk}. Такође, у програму могу да постоје системски позиви за алоцирање меморије, \textit{Massif} неће узети у обзир ту меморију током анализе програма.

\indent Уколико нам је од велико значаја да се узме у обзир сва алоцирана меморија у нашем програму, потребно је укључити опцију \textit{-\--pages-as-heap=yes}. Укључивањем ове опције, \textit{Massif} неће профајлирати хип меморију, већ страније у меморији. 


\section{DRD}

\chapter{FPXX}
\label{chp:fpxx}

\chapter{Закључак}

% ------------------------------------------------------------------------------
%\pangrami

%\pangrami

% ------------------------------------------------------------------------------
% Literatura
% ------------------------------------------------------------------------------
\literatura

% ==============================================================================
% Završni deo teze i prilozi
\backmatter
% ==============================================================================

% ------------------------------------------------------------------------------
% Biografija kandidata
\begin{biografija}
\textbf{Вук Стефановић Караџић} (\emph{Тршић, 26. октобар/6. новембар
  1787. — Беч, 7. фебруар 1864.}) био је српски филолог, реформатор
српског језика, сакупљач народних умотворина и писац првог речника
српског језика.  Вук је најзначајнија личност српске књижевности прве
половине XIX века. Стекао је и неколико почасних доктората.
Учествовао је у Првом српском устанку као писар и чиновник у
Неготинској крајини, а након слома устанка преселио се у Беч,
1813. године. Ту је упознао Јернеја Копитара, цензора словенских
књига, на чији је подстицај кренуо у прикупљање српских народних
песама, реформу ћирилице и борбу за увођење народног језика у српску
књижевност. Вуковим реформама у српски језик је уведен фонетски
правопис, а српски језик је потиснуо славеносрпски језик који је у то
време био језик образованих људи. Тако се као најважније године Вукове
реформе истичу 1818., 1836., 1839., 1847. и 1852.
\end{biografija}
% ------------------------------------------------------------------------------

\end{document} 